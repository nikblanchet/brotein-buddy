# Teaching Document: Client-Side Routing Infrastructure (Task 2.2)

## Overview

This document explains the routing infrastructure setup for BroteinBuddy, completed in task 2.2. We'll explore why we made specific technical decisions, how the implementation enables parallel development, and what patterns emerge that you can apply to other projects.

**What was accomplished:**

- Installed and configured `svelte-spa-router` for hash-based routing
- Created centralized route configuration with type-safe navigation constants
- Implemented 7 placeholder components representing all app screens
- Refactored App.svelte into a minimal routing container
- Configured path aliases ($lib) for cleaner imports
- Wrote comprehensive tests: 18 unit tests + 26 E2E tests
- Documented the decision in ADR-006

**Key Learning Goals:**

1. Understanding hash-based routing vs history API
2. The placeholder pattern for parallel development
3. Type-safe navigation in TypeScript
4. Router library selection criteria
5. Path alias configuration
6. Testing strategies for routing

---

## 1. Why Hash-Based Routing?

### The Fundamentals

Client-side routing comes in two flavors:

**History API Routing** produces clean URLs:

```
https://broteinbuddy.app/inventory
https://broteinbuddy.app/inventory/box-123/edit
```

**Hash-Based Routing** uses URL fragments:

```
https://broteinbuddy.app/#/inventory
https://broteinbuddy.app/#/inventory/box-123/edit
```

### The Server Configuration Trade-off

Here's the critical difference: with history API routing, when a user visits `/inventory` directly (not by navigating from your app), the browser sends a request to the server for that path. Your server needs to be configured to return `index.html` for ALL routes, not just the root.

**On Vercel with History API, you'd need:**

```json
// vercel.json
{
  "rewrites": [{ "source": "/:path*", "destination": "/index.html" }]
}
```

**With hash-based routing:** The browser always requests `/`, and the `#/inventory` part never reaches the server. The hash fragment is purely client-side. Zero server configuration needed.

### Why This Matters for PWAs

BroteinBuddy is a Progressive Web App with specific constraints:

1. **Static Deployment:** We deploy to Vercel as static files. No server-side code.
2. **Installability:** Users install the app on their iOS home screen.
3. **Offline-First:** The app must work without a network connection.
4. **Deep Linking:** Users should be able to bookmark specific screens.

Hash-based routing aligns perfectly with these constraints:

- Works immediately with static hosting (no build config needed)
- Deep links work from the iOS home screen
- No server round-trips means offline functionality is simpler
- URL aesthetics are less important for utility apps (vs public websites)

**The Decision:** For a PWA that's a personal utility tool (not a public content site), the deployment simplicity of hash routing far outweighs having slightly prettier URLs.

---

## 2. The Placeholder Pattern: Enabling Parallel Development

### The Problem We're Solving

BroteinBuddy has 7 distinct screens. Without routing infrastructure, here's what happens:

**Bad Approach:** Implement screens sequentially in App.svelte

```svelte
<!-- App.svelte becomes a mess -->
<script>
  let currentScreen = 'home';
</script>

{#if currentScreen === 'home'}
  <!-- Home screen code -->
{:else if currentScreen === 'random'}
  <!-- Random selection code -->
{:else if currentScreen === 'inventory'}
  <!-- Inventory code -->
{/if}
```

**Problems:**

- Every feature branch modifies App.svelte → merge conflicts
- Can't develop screens in parallel → sequential development
- No URL-based navigation → can't bookmark screens
- Testing requires simulating state changes instead of navigation

### The Solution: Placeholder-First Development

We create the routing infrastructure FIRST, before implementing any screens:

**Step 1:** Define all routes upfront

```typescript
// src/lib/router/routes.ts
export const routes = {
  '/': Home,
  '/random': Random,
  '/random/confirm': RandomConfirm,
  '/inventory': Inventory,
  '/inventory/:boxId/edit': InventoryBoxEdit,
  '/inventory/rearrange': InventoryRearrange,
  '*': NotFound,
};
```

**Step 2:** Create minimal placeholder for each route

```svelte
<!-- src/routes/Home.svelte -->
<script lang="ts">
  /**
   * Home Screen - Placeholder
   *
   * This is a placeholder implementation that will be replaced
   * in task 2.3 with the full home screen functionality.
   */
</script>

<div class="placeholder-screen">
  <h1>Home</h1>
  <p class="status">Coming soon</p>
  <p class="description">
    The home screen will provide four main actions: random flavor selection, favorite flavor
    quick-pick, manual flavor selection, and inventory management.
  </p>
</div>

<style>
  /* Consistent styling using design system tokens */
  .placeholder-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: var(--space-6);
    text-align: center;
    gap: var(--space-4);
  }
</style>
```

**Step 3:** App.svelte becomes trivial

```svelte
<!-- src/App.svelte -->
<script lang="ts">
  import Router from 'svelte-spa-router';
  import { routes } from './lib/router/routes';
</script>

<Router {routes} />
```

### Why This Works

Now, tasks 2.3-2.7 can work in parallel:

- **Task 2.3** (Home screen): Replace `src/routes/Home.svelte` placeholder
- **Task 2.4** (Random selection): Replace `src/routes/Random.svelte` and `src/routes/RandomConfirm.svelte`
- **Task 2.5** (Inventory): Replace `src/routes/Inventory.svelte`
- **Task 2.6** (Box edit): Replace `src/routes/InventoryBoxEdit.svelte`
- **Task 2.7** (Rearrange): Replace `src/routes/InventoryRearrange.svelte`

Each task works in isolation. No merge conflicts. No blocking dependencies.

### Placeholder Benefits

**1. Visual Feedback During Development**

Developers can navigate to any route and see:

- The screen exists (not 404)
- What functionality is coming
- Consistent design system styling
- Working back buttons

**2. E2E Test Foundation**

We can write navigation tests immediately:

```typescript
test('navigates to inventory screen', async ({ page }) => {
  await page.goto('/#/inventory');
  await expect(page.locator('h1')).toContainText('Inventory');
  // When task 2.5 replaces the placeholder, this test still works!
});
```

**3. Documentation Through Code**

Placeholders document what each screen will do:

```svelte
<p class="description">
  The home screen will provide four main actions: random flavor selection, favorite flavor
  quick-pick, manual flavor selection, and inventory management.
</p>
```

**Pattern Takeaway:** When building a multi-screen application, invest upfront in routing infrastructure with placeholders. It unlocks parallel development and provides a solid foundation for testing and documentation.

---

## 3. Type-Safe Navigation: Eliminating String Typos

### The Problem with String-Based Routing

Most routing examples show string literals:

```typescript
// Brittle: typos cause runtime errors
push('/inventroy'); // BUG: typo in "inventory"
push('/inventory/' + boxId + '/edut'); // BUG: typo in "edit"
```

TypeScript doesn't catch these errors because strings are just strings. The bug only appears when a user clicks the broken link.

### The ROUTES Constants Pattern

We export typed constants for every route:

```typescript
// src/lib/router/routes.ts
export const ROUTES = {
  /** Home screen with main action buttons */
  HOME: '/',

  /** Random flavor selection screen */
  RANDOM: '/random',

  /** Inventory management screen (visual and table views) */
  INVENTORY: '/inventory',

  /**
   * Individual box edit screen
   *
   * @param boxId - The unique identifier of the box to edit
   * @returns Route string with boxId parameter
   */
  INVENTORY_BOX_EDIT: (boxId: string): string => `/inventory/${boxId}/edit`,

  /** Drag-and-drop box rearrangement screen */
  INVENTORY_REARRANGE: '/inventory/rearrange',
} as const;
```

### Usage in Components

**Before (string literals):**

```svelte
<script lang="ts">
  import { push } from 'svelte-spa-router';

  function goToInventory() {
    push('/inventory'); // Easy to typo
  }

  function editBox(boxId: string) {
    push(`/inventory/${boxId}/edit`); // Error-prone string concatenation
  }
</script>
```

**After (typed constants):**

```svelte
<script lang="ts">
  import { push } from 'svelte-spa-router';
  import { ROUTES } from '$lib/router/routes';

  function goToInventory() {
    push(ROUTES.INVENTORY); // Autocomplete + compile-time checking
  }

  function editBox(boxId: string) {
    push(ROUTES.INVENTORY_BOX_EDIT(boxId)); // Type-safe parameter handling
  }
</script>
```

### Benefits of This Pattern

**1. Autocomplete Support**

When you type `ROUTES.` in your editor, you see all available routes with their documentation.

**2. Refactoring Safety**

If you need to rename a route from `/inventory` to `/boxes`, you change it in ONE place:

```typescript
export const ROUTES = {
  INVENTORY: '/boxes', // Changed here
  // All usages automatically update
};
```

**3. Type-Checked Parameters**

For parameterized routes, TypeScript ensures you provide the required parameters:

```typescript
push(ROUTES.INVENTORY_BOX_EDIT()); // ERROR: Expected 1 argument
push(ROUTES.INVENTORY_BOX_EDIT(123)); // ERROR: Expected string, got number
push(ROUTES.INVENTORY_BOX_EDIT('box-123')); // OK
```

**4. Documentation at Call Site**

Hover over `ROUTES.INVENTORY_BOX_EDIT` and see JSDoc:

```
Individual box edit screen
@param boxId - The unique identifier of the box to edit
@returns Route string with boxId parameter
```

### Route Parameter Type Safety

We also export types for route parameters:

```typescript
export interface RouteParams {
  /** Parameters for the inventory box edit route */
  inventoryBoxEdit: {
    boxId: string;
  };
}
```

In your component, extract parameters type-safely:

```svelte
<script lang="ts">
  import type { RouteParams } from '$lib/router/routes';

  // svelte-spa-router provides params as an object
  export let params: RouteParams['inventoryBoxEdit'];

  // TypeScript knows params.boxId exists and is a string
  console.log(`Editing box: ${params.boxId}`);
</script>
```

**Pattern Takeaway:** Always wrap route strings in typed constants. The small upfront effort pays massive dividends in maintainability, especially as your app grows to 20+ routes.

---

## 4. Why svelte-spa-router? Library Selection Criteria

We evaluated 4 routing libraries. Here's what we learned about choosing dependencies.

### The Candidates

1. **svelte-spa-router** (6KB, 2.4k stars)
2. **tinro** (3KB, 750 stars)
3. **SvelteKit** (50KB+, official Svelte framework)
4. **Custom implementation** (4-5KB, maintenance burden)

### Selection Criteria

**1. Compatibility with Our Architecture**

BroteinBuddy uses:

- Vite for builds (not SvelteKit)
- Static hosting on Vercel
- LocalStorage for persistence (no server)
- Svelte 5

This eliminated SvelteKit immediately - it's a full framework that would require restructuring our entire Phase 0 setup. Using a framework for routing alone would be like buying a car when you just need a bicycle.

**2. Deployment Simplicity**

We prioritize zero-configuration deployments. This eliminated `tinro`:

- tinro uses the History API
- Requires Vercel rewrites configuration
- Adds a deployment step that can fail

svelte-spa-router's hash routing works with zero config.

**3. Bundle Size vs Features**

Let's compare what matters for our use case:

| Feature                | svelte-spa-router | tinro | SvelteKit |
| ---------------------- | ----------------- | ----- | --------- |
| Route parameters       | ✅                | ✅    | ✅        |
| Hash routing           | ✅                | ❌    | ❌        |
| Active route detection | ✅                | ✅    | ✅        |
| Route guards           | ✅                | ❌    | ✅        |
| Bundle size            | 6KB               | 3KB   | 50KB+     |
| Server config needed   | ❌                | ✅    | ✅        |

tinro is 3KB smaller, but lacks route guards we might need later. For a PWA (not a landing page), 3KB is negligible - that's 0.05% of a typical 6MB PWA bundle.

**4. Community and Documentation**

svelte-spa-router:

- 2.4k GitHub stars
- Active maintenance (last updated Oct 2024)
- Comprehensive documentation
- Used in production by many Svelte apps
- Well-documented edge cases

tinro:

- 750 stars
- Smaller community
- Less Stack Overflow coverage
- Fewer battle-tested production deployments

When you hit an edge case at 2am, you want Stack Overflow answers and GitHub issues, not silence.

**5. Developer Experience**

svelte-spa-router has a simple, predictable API:

```typescript
// Define routes
export const routes = { '/': Home, '/about': About };

// Navigate
import { push } from 'svelte-spa-router';
push('/about');

// Get current route
import { location } from 'svelte-spa-router';
$location; // reactive, updates automatically
```

No magic, no surprises.

### The Decision

svelte-spa-router wins because:

- Works with our architecture (Vite, static deployment)
- Zero configuration deployment
- Sufficient features for our needs
- Strong community support
- Svelte 5 compatible

**3KB savings vs hash routing + mature library** is an easy trade-off for a PWA.

### Library Selection Lessons

**What we learned:**

1. **Match your architecture first:** Eliminate libraries that require restructuring
2. **Deployment simplicity > bundle size:** For PWAs, a few KB doesn't matter
3. **Community size correlates with problem-solving:** More users = more solved edge cases
4. **Feature parity vs feature bloat:** Get what you need, not everything possible
5. **The second-smallest isn't always wrong:** Sometimes the slightly larger library is the better choice

**Pattern Takeaway:** When choosing libraries, prioritize architectural fit and deployment simplicity over marginal size differences. A 3KB savings means nothing if it costs you hours of debugging or deployment configuration.

---

## 5. Path Alias Configuration: The $lib Pattern

### The Import Pain

Before path aliases:

```typescript
// In src/routes/InventoryBoxEdit.svelte
import { ROUTES } from '../../lib/router/routes';
import { inventoryStore } from '../../lib/stores/inventory';
import type { Box } from '../../lib/types/models';

// In src/lib/services/inventory.ts
import type { Box } from '../types/models';
import { inventoryStore } from '../stores/inventory';
```

**Problems:**

1. Relative path mental math: "Am I two levels up? Three?"
2. Breaks when you move files
3. Hard to grep for imports
4. Inconsistent depth across files

### The $lib Alias Solution

Configure a path alias that always points to `src/lib`:

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [svelte()],
  resolve: {
    alias: {
      $lib: path.resolve('./src/lib'),
    },
  },
});
```

Now ALL imports look the same:

```typescript
// In src/routes/InventoryBoxEdit.svelte
import { ROUTES } from '$lib/router/routes';
import { inventoryStore } from '$lib/stores/inventory';
import type { Box } from '$lib/types/models';

// In src/lib/services/inventory.ts (same pattern!)
import type { Box } from '$lib/types/models';
import { inventoryStore } from '$lib/stores/inventory';
```

### TypeScript Integration

Vite handles the alias at build time, but TypeScript needs to know about it for type checking:

```json
// tsconfig.app.json
{
  "compilerOptions": {
    "paths": {
      "$lib/*": ["./src/lib/*"]
    }
  }
}
```

Now TypeScript:

- Provides autocomplete for `$lib/` imports
- Type-checks across alias boundaries
- Shows correct error locations

### Why $lib Specifically?

The `$` prefix is a SvelteKit convention that means "this is a special path, not a node_modules package". While we're not using SvelteKit, following this convention:

1. Makes the alias visually distinct from npm packages
2. Prevents naming conflicts with future npm packages named "lib"
3. Maintains consistency if you later migrate to SvelteKit
4. Familiar to any Svelte developer

### Testing Configuration

Your test framework also needs to understand the alias:

```typescript
// vitest.config.ts (imported from vite.config.ts)
export default defineConfig({
  resolve: {
    alias: {
      $lib: path.resolve('./src/lib'),
    },
  },
  test: {
    // Test configuration
  },
});
```

Now tests can import using `$lib/` just like your app code.

### Benefits in Practice

**1. Move files without breaking imports**

Move `src/lib/types/models.ts` to `src/lib/models/types.ts`:

```typescript
// Before: import type { Box } from '$lib/types/models';
// After:  import type { Box } from '$lib/models/types';
// Only the file location in the import changes, not the relative depth
```

**2. Consistent import patterns**

All library imports follow the same pattern:

```typescript
import { x } from '$lib/module/file';
```

No mixing `../../` with `../` with `$lib/`.

**3. Easier code review**

Reviewers see import structure at a glance:

```typescript
import { push } from 'svelte-spa-router'; // External package
import { ROUTES } from '$lib/router/routes'; // Internal library
import type { Box } from '$lib/types/models'; // Internal types
```

**4. Better autocomplete**

Type `$lib/` and your editor shows the complete directory structure.

**Pattern Takeaway:** Configure path aliases early. They're a one-time setup cost with continuous benefits. Use the `$` prefix for special paths to distinguish them from npm packages.

---

## 6. Testing Strategy: Unit vs E2E for Routing

We wrote 44 tests for routing infrastructure:

- **18 unit tests** for route configuration
- **26 E2E tests** for navigation behavior

Let's understand when to use each approach.

### Unit Tests: Route Configuration Logic

Unit tests verify the route configuration works as designed:

```typescript
// tests/unit/router/routes.test.ts
describe('ROUTES constants', () => {
  it('defines home route', () => {
    expect(ROUTES.HOME).toBe('/');
  });

  it('defines inventory route', () => {
    expect(ROUTES.INVENTORY).toBe('/inventory');
  });
});

describe('ROUTES.INVENTORY_BOX_EDIT parameter helper', () => {
  it('generates route with simple boxId', () => {
    expect(ROUTES.INVENTORY_BOX_EDIT('box123')).toBe('/inventory/box123/edit');
  });

  it('generates route with UUID format boxId', () => {
    const uuid = '550e8400-e29b-41d4-a716-446655440000';
    expect(ROUTES.INVENTORY_BOX_EDIT(uuid)).toBe(`/inventory/${uuid}/edit`);
  });

  it('handles special characters in boxId', () => {
    expect(ROUTES.INVENTORY_BOX_EDIT('box-123_ABC')).toBe('/inventory/box-123_ABC/edit');
  });
});
```

**What unit tests verify:**

- Route constants have correct string values
- Parameter helpers generate correct paths
- Type definitions compile correctly
- Edge cases like special characters, UUIDs, etc.

**Why unit tests here:**

- Fast (milliseconds)
- No browser startup overhead
- Easy to test edge cases
- Clear failure messages
- High confidence in route path generation

**Coverage: 100%** for `routes.ts`. Every route constant, every parameter helper, every edge case.

### E2E Tests: Navigation Behavior

E2E tests verify routing works in a real browser:

```typescript
// tests/e2e/routing.spec.ts
test('navigates to inventory screen', async ({ page }) => {
  await page.goto('/#/inventory');
  await expect(page.locator('h1')).toContainText('Inventory');
  await expect(page).toHaveURL(/#\/inventory$/);
});

test('back button navigates to previous route', async ({ page }) => {
  await page.goto('/');
  await expect(page.locator('h1')).toContainText('Home');

  await page.goto('/#/random');
  await expect(page.locator('h1')).toContainText('Random Selection');

  await page.goBack();
  await expect(page).toHaveURL(/#\/$/);
  await expect(page.locator('h1')).toContainText('Home');
});

test('404 page shows for invalid routes', async ({ page }) => {
  await page.goto('/#/this-route-does-not-exist');
  await expect(page.locator('h1')).toContainText('404');
  await expect(page.locator('h2')).toContainText('Page Not Found');
});
```

**What E2E tests verify:**

- Routes load the correct components
- URLs update correctly in the browser
- Back/forward buttons work
- Deep linking works (direct URL access)
- Button navigation works
- 404 handling works
- Hash format is preserved

**Why E2E tests here:**

- Tests real browser behavior (not jsdom)
- Verifies svelte-spa-router integration
- Tests actual hash routing in URLs
- Catches browser-specific issues
- Verifies the full navigation flow

**Coverage:** 26 tests covering:

- 7 routes (basic loading)
- 4 button navigation flows
- 3 browser navigation scenarios
- 5 deep linking cases
- 4 404 error cases
- 2 hash URL format tests
- 1 placeholder styling test

### The Testing Strategy Principle

**Unit tests answer:** "Does my code logic work?"
**E2E tests answer:** "Does the user experience work?"

For routing:

- Unit test the route configuration (our code)
- E2E test the navigation experience (user behavior)

### What Could Go Wrong?

Both test levels catch different bugs:

**Caught by unit tests:**

```typescript
// BUG: typo in route string
INVENTORY_BOX_EDIT: (boxId: string) => `/inventory/${boxId}/edut`,
// Unit test fails: expect('/inventory/box-123/edit').toBe('/inventory/box-123/edut')
```

**Caught by E2E tests:**

```typescript
// BUG: wrong component assigned to route
export const routes = {
  '/inventory': Home, // Should be Inventory, not Home
};
// E2E test fails: expect(h1).toContainText('Inventory') but got 'Home'
```

**Caught by E2E tests:**

```typescript
// BUG: svelte-spa-router not working with Svelte 5
// Unit tests all pass (they don't import svelte-spa-router)
// E2E tests fail: route navigation doesn't update component
```

### Testing Philosophy

We achieve **100% confidence** in routing by combining:

1. **100% unit test coverage** of route configuration logic
2. **Comprehensive E2E coverage** of user navigation scenarios
3. **Fast feedback loop:** Unit tests run in CI, E2E tests run on PR

**Pattern Takeaway:** For routing, unit test your configuration logic exhaustively (fast, deterministic), and E2E test the critical user flows (slower, but verifies real behavior). Don't try to unit test browser behavior, and don't try to E2E test parameter string generation.

---

## 7. Common Pitfalls and How We Avoided Them

### Pitfall 1: Hardcoded Route Strings Everywhere

**The problem:**

```typescript
// Throughout your codebase
push('/inventory');
push('/inventory/box-123/edit');
// Later, you rename /inventory to /boxes
// Good luck finding every string!
```

**How we avoided it:**

- Exported ROUTES constants from a single source of truth
- Used typed parameter helpers for dynamic routes
- Unit tests verify the constants match expected values

**Result:** Renaming a route requires changing ONE line of code.

### Pitfall 2: No Placeholder Components

**The problem:**

```typescript
// routes.ts references components that don't exist yet
import Home from '../routes/Home.svelte'; // ERROR: file doesn't exist
```

**How we avoided it:**

- Created minimal placeholders for all routes upfront
- Placeholders show "Coming soon" messaging
- Tests run against placeholders, still pass when replaced

**Result:** Routes work immediately, and tasks 2.3-2.7 can develop in parallel.

### Pitfall 3: Forgetting TypeScript Configuration

**The problem:**

```typescript
// In your component
import { ROUTES } from '$lib/router/routes';
// TypeScript error: Cannot find module '$lib/router/routes'
// (But Vite builds successfully because it knows about the alias!)
```

**How we avoided it:**

- Configured path alias in BOTH vite.config.ts and tsconfig.app.json
- Vite handles runtime resolution
- TypeScript handles type checking

**Result:** Autocomplete works, type checking works, builds work.

### Pitfall 4: No 404 Handling

**The problem:**

```typescript
// User visits /#/typo
// App shows blank screen or crashes
```

**How we avoided it:**

- Added catch-all route: `'*': NotFound`
- NotFound component provides clear messaging and navigation home
- E2E tests verify 404 behavior

**Result:** Invalid routes show friendly error page instead of breaking.

### Pitfall 5: Testing Only Happy Path

**The problem:**

```typescript
// Only test: "Can I navigate to /inventory?"
// Forget to test: back button, deep links, 404s, parameters
```

**How we avoided it:**

- 26 E2E tests covering 6 different routing scenarios
- Browser navigation (back/forward)
- Deep linking (direct URL access)
- Parameterized routes with various ID formats
- Error cases (404s, malformed routes)

**Result:** Comprehensive confidence in routing behavior.

### Pitfall 6: Mixing Relative Imports with Path Aliases

**The problem:**

```typescript
// Inconsistent import styles throughout codebase
import { ROUTES } from '../../lib/router/routes';
import { inventoryStore } from '$lib/stores/inventory';
```

**How we avoided it:**

- Established pattern: ALWAYS use $lib for internal library imports
- ESLint rule could enforce this (optional)
- Code review checks for consistency

**Result:** Consistent, greppable import patterns.

---

## 8. Key Takeaways

### For BroteinBuddy Specifically

1. **Hash routing fits PWA deployment:** Zero Vercel configuration needed
2. **Placeholders enable parallelization:** Tasks 2.3-2.7 won't block each other
3. **Type-safe routes prevent typos:** ROUTES constants catch errors at compile time
4. **svelte-spa-router is the right tool:** Simple, proven, Svelte 5 compatible
5. **$lib aliases improve maintainability:** Consistent imports across all files

### General Principles You Can Apply

1. **Choose routing based on deployment model:** SPAs with static hosting → hash routing; server-rendered apps → history API
2. **Create routing infrastructure first:** Enables parallel feature development
3. **Wrap routes in typed constants:** Small upfront cost, massive refactoring benefits
4. **Library selection criteria:** Architectural fit > bundle size for non-trivial apps
5. **Configure path aliases early:** One-time setup, continuous benefits
6. **Test routing at two levels:** Unit test configuration logic, E2E test user navigation

### What's Next?

Now that routing infrastructure is complete:

- **Task 2.3:** Implement Home screen (replace Home.svelte placeholder)
- **Task 2.4:** Implement Random selection flow (replace Random.svelte and RandomConfirm.svelte)
- **Task 2.5:** Implement Inventory screen (replace Inventory.svelte)
- **Task 2.6:** Implement Box edit screen (replace InventoryBoxEdit.svelte)
- **Task 2.7:** Implement Rearrange screen (replace InventoryRearrange.svelte)

Each task works in its own file, no merge conflicts, no blocking dependencies.

---

## 9. Further Reading

**ADRs (Architecture Decision Records):**

- [ADR-006: Routing Strategy](../adr/006-routing-strategy.md) - Full decision rationale with alternatives considered

**Implementation Files:**

- [src/lib/router/routes.ts](../../src/lib/router/routes.ts) - Route configuration and ROUTES constants
- [src/App.svelte](../../src/App.svelte) - Routing container
- [src/routes/Home.svelte](../../src/routes/Home.svelte) - Example placeholder component

**Test Files:**

- [tests/unit/router/routes.test.ts](../../tests/unit/router/routes.test.ts) - Unit tests for route configuration
- [tests/e2e/routing.spec.ts](../../tests/e2e/routing.spec.ts) - E2E tests for navigation behavior

**Configuration Files:**

- [vite.config.ts](../../vite.config.ts) - Path alias configuration for Vite
- [tsconfig.app.json](../../tsconfig.app.json) - Path alias configuration for TypeScript

**External Resources:**

- [svelte-spa-router Documentation](https://github.com/ItalyPaleAle/svelte-spa-router)
- [Hash-based routing vs History API](https://stackoverflow.com/questions/36289683/what-is-the-difference-between-hash-and-history-html5-api-for-client-side-routi)
- [Progressive Web Apps on MDN](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps)

---

**Document Status:** Complete
**Last Updated:** 2025-10-28
**Task:** 2.2 - Routing Infrastructure Setup
**PR:** #43
