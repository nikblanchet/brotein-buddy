# Home Screen Component: Mobile-First UI Design and Modern Svelte Patterns

**Deliverable:** 2.3 - Home Screen Component
**Created:** 2025-10-28
**Author:** Claude Code

---

## Overview

This document explains the implementation of the BroteinBuddy home screen - the main navigation hub that users see when opening the app. While it might look like "just four buttons," this component demonstrates several important concepts in modern web development: mobile-first responsive design, reactive state management with Svelte 5, defensive programming practices, and comprehensive testing strategies.

This is the kind of component that seems simple but teaches fundamental patterns you'll use throughout your career.

## What We Built

The home screen is the entry point to BroteinBuddy. It presents four navigation buttons arranged in order of importance:

1. **Random Pick** (primary, large) - Uses the weighted random selection algorithm
2. **Favorite Flavor** (primary, large) - Quick-pick for a configured favorite flavor
3. **Choose Flavor** (secondary, medium) - Manual flavor selection
4. **Manage Inventory** (ghost, medium) - Inventory management

The screen adapts its layout and typography for different screen sizes, integrates with application state to display the favorite flavor name, and provides clear visual hierarchy to guide user attention.

## Problem We Solved

When you're building a mobile-first application, your home screen needs to solve several problems simultaneously:

1. **Navigation clarity**: Users should immediately understand their options
2. **Touch-friendliness**: Buttons must be large enough for fingers (44x44px minimum)
3. **Visual hierarchy**: Most important actions should stand out
4. **Responsive design**: Layout must work on phone, tablet, and desktop
5. **State integration**: Display dynamic content (like favorite flavor name)
6. **Null safety**: Handle missing data gracefully (no favorite configured yet)

The challenge is balancing all these requirements while keeping the code simple and testable.

## Design Approach

### Mobile-First Responsive Design

We designed for mobile first, then enhanced for larger screens:

```css
/* Base styles: mobile */
.home-screen {
  padding: var(--space-6); /* 24px */
  gap: var(--space-8); /* 32px */
}

h1 {
  font-size: var(--font-size-3xl); /* 30px */
}

/* Enhancement: tablet/desktop */
@media (min-width: 768px) {
  .home-screen {
    padding: var(--space-8); /* 32px - more breathing room */
  }

  h1 {
    font-size: var(--font-size-4xl); /* 36px - larger title */
  }
}
```

**Why mobile-first?**

It's easier to add complexity than remove it. When you start with mobile constraints, you focus on the essentials. Then you enhance for larger screens by adding more spacing, larger typography, or additional features. The reverse (desktop-first) often leads to bloated mobile experiences.

### Visual Hierarchy Through Design System

We used the design system from deliverable 2.1 to create clear hierarchy:

```svelte
<!-- Tier 1: Primary actions (large, bold) -->
<Button variant="primary" size="lg">Random Pick</Button>
<Button variant="primary" size="lg">Favorite Flavor</Button>

<!-- Tier 2: Secondary action (less prominent) -->
<Button variant="secondary" size="base">Choose Flavor</Button>

<!-- Tier 3: Utility action (subtle) -->
<Button variant="ghost" size="base">Manage Inventory</Button>
```

The button variants use different visual weights:

- **Primary**: High contrast, saturated color, strong shadow
- **Secondary**: Medium contrast, outlined style
- **Ghost**: Low contrast, minimal styling

This creates a "visual breadcrumb trail" - your eye naturally moves from most prominent to least prominent, which matches the expected usage frequency.

### Svelte 5 Reactive State with $derived

The favorite flavor button needs to:

1. Look up the flavor by ID from application state
2. Display the flavor name if found, or "Set Favorite" if not
3. Update automatically when state changes

Svelte 5's `$derived` rune makes this elegant:

```typescript
// Reactive: Get the favorite flavor object (or null)
let favoriteFlavor = $derived(maybeGetFlavor($appState.favoriteFlavorId, $appState.flavors));

// Reactive: Compute the button label based on flavor
let favoriteButtonLabel = $derived(
  favoriteFlavor ? `❤️ ${favoriteFlavor.name}` : '❤️ Set Favorite'
);
```

**What's happening here:**

1. `$derived` creates a reactive variable that recalculates whenever its dependencies change
2. `$appState` is a Svelte store subscription (auto-unwrapped with `$`)
3. When `favoriteFlavorId` or `flavors` changes, `favoriteFlavor` updates
4. When `favoriteFlavor` changes, `favoriteButtonLabel` updates
5. When `favoriteButtonLabel` changes, the DOM updates

All of this happens automatically. No manual subscriptions, no useEffect, no lifecycle methods. This is the power of Svelte's reactivity.

### Defensive Programming: The maybeGetFlavor Utility

Look at how we safely look up the favorite flavor:

```typescript
export function maybeGetFlavor(
  flavorId: string | null | undefined,
  flavors: Flavor[]
): Flavor | null {
  // Handle null/undefined/empty flavor ID
  if (!flavorId) {
    return null;
  }

  // Handle null/undefined flavors array
  if (!Array.isArray(flavors)) {
    return null;
  }

  // Find matching flavor
  return flavors.find((f) => f.id === flavorId) ?? null;
}
```

**Why all the null checks?**

This function could be called during initialization before state is fully loaded. Or the user might not have configured a favorite yet. Or there could be data corruption where the favoriteFlavorId points to a flavor that no longer exists.

Instead of crashing with "Cannot read property 'id' of undefined", we handle all these cases gracefully and return null. The calling code can then decide what to do (in our case, disable the button and show "Set Favorite").

This pattern is called **defensive programming** - assume your inputs might be invalid and handle them gracefully. It's especially important in UI code where data comes from external sources (localStorage, user input, APIs).

**The "maybe" naming convention:**

Functions that might not find what they're looking for often use "maybe", "try", or "find" prefixes:

- `maybeGetFlavor` - might return null
- `tryParse` - might fail
- `findUser` - might not exist

This signals to the caller: "Check the result before using it!"

## Implementation Details

### Component Structure

```svelte
<script lang="ts">
  // Imports
  import Button from '$lib/components/Button.svelte';
  import { push } from 'svelte-spa-router';
  import { ROUTES } from '$lib/router/routes';
  import { appState } from '$lib/stores';
  import { maybeGetFlavor } from '$lib/utils/flavor';

  // Reactive state
  let favoriteFlavor = $derived(...);
  let favoriteButtonLabel = $derived(...);

  // Event handlers
  function handleRandomClick() { ... }
  function handleFavoriteClick() { ... }
  function handleManualClick() { ... }
  function handleInventoryClick() { ... }
</script>

<!-- Template -->
<div class="home-screen">
  <header class="home-header">...</header>
  <div class="buttons-container">...</div>
</div>

<!-- Scoped styles -->
<style>
...
</style>
```

**Why this structure?**

1. **Script section first**: Imports, state, and logic
2. **Template section**: Markup and component composition
3. **Style section**: Scoped CSS

This is Svelte's single-file component (SFC) pattern. Everything related to the home screen lives in one file, making it easy to understand and maintain.

### Navigation Pattern

All navigation uses the routing framework from deliverable 2.2:

```typescript
import { push } from 'svelte-spa-router';
import { ROUTES } from '$lib/router/routes';

function handleRandomClick() {
  push(ROUTES.RANDOM); // Navigate to /random
}
```

**Why use ROUTES constants instead of strings?**

```typescript
// Bad: Magic strings (typo-prone, hard to refactor)
push('/random');

// Good: Named constants (type-safe, refactorable)
push(ROUTES.RANDOM);
```

If we ever need to change the URL structure, we update one place (routes.ts) and the compiler catches any missing updates. Magic strings would silently break.

### CSS Custom Properties (Design Tokens)

All styling uses CSS custom properties from the design system:

```css
.home-screen {
  padding: var(--space-6); /* Not: 24px */
  gap: var(--space-8); /* Not: 32px */
}

h1 {
  font-size: var(--font-size-3xl); /* Not: 30px */
  font-weight: var(--font-weight-bold); /* Not: 700 */
  color: var(--color-text-primary); /* Not: #1a1a1a */
}
```

**Why use variables instead of hard-coded values?**

1. **Consistency**: Every component uses the same spacing/color/typography scale
2. **Themability**: Change one variable, update the entire app
3. **Dark mode**: Variables can change based on `prefers-color-scheme`
4. **Maintainability**: "What's space-6?" is clearer than "What's 24px?"

This is the foundation of a design system - shared tokens that ensure visual consistency.

### Accessibility Considerations

**Minimum touch targets:**

```css
/* Button component enforces 44x44px minimum */
button {
  min-height: 44px;
  padding: var(--space-3) var(--space-6);
}
```

Apple's Human Interface Guidelines and Google's Material Design both recommend 44-48px touch targets. Smaller targets lead to frustration and misclicks.

**Semantic HTML:**

```html
<header class="home-header">
  <h1>Protein Buddy</h1>
  <p class="subtitle">Track & Pick Your Shakes</p>
</header>
```

We use semantic elements (`<header>`, `<h1>`) instead of generic `<div>`s. This helps:

- Screen readers understand page structure
- Search engines understand content hierarchy
- Developers understand intent

**Keyboard navigation:**

All interactive elements are `<button>` components that are naturally keyboard-accessible. Tab through the buttons, press Enter or Space to activate. No mouse required.

**Disabled state feedback:**

```svelte
<Button disabled={!favoriteFlavor}>
  {favoriteButtonLabel}
</Button>
```

When no favorite is configured, the button is disabled. This provides:

- Visual feedback (dimmed appearance)
- Interaction feedback (cursor: not-allowed)
- Screen reader feedback (aria-disabled attribute)

## Testing Strategy

We used a two-tier testing approach: unit tests for utilities, E2E tests for user workflows.

### Unit Tests: maybeGetFlavor Utility

The flavor lookup utility has **20 unit tests with 100% coverage**:

```typescript
describe('maybeGetFlavor', () => {
  describe('valid inputs', () => {
    // Returns flavor when ID exists
    // Returns correct flavor from multiple options
    // Returns first match if duplicates exist
  });

  describe('null or undefined inputs', () => {
    // Returns null when flavorId is null
    // Returns null when flavorId is undefined
    // Returns null when flavors array is null
    // Returns null when both inputs are null
  });

  describe('flavor not found', () => {
    // Returns null when ID doesn't exist
    // Returns null when ID is empty string
    // Returns null when searching empty array
    // Case-sensitive ID matching
  });

  describe('edge cases', () => {
    // Single flavor array
    // Special characters in IDs
    // Unicode characters in names
    // No mutation of input array
    // Returns reference, not copy
  });

  describe('type safety', () => {
    // Returns properly typed Flavor object
    // Returns null type when not found
  });
});
```

**Why so many tests for a simple function?**

Each test validates one specific behavior or edge case. When a test fails, the name tells you exactly what broke. This is better than one giant test that checks everything:

```typescript
// Bad: One test for everything
it('works', () => {
  // 50 assertions
});

// Good: One test per behavior
it('returns flavor when ID exists in array', () => {
  const result = maybeGetFlavor('choc', flavors);
  expect(result).toEqual(flavors[0]);
});
```

**100% coverage on utilities:**

Utility functions are used throughout the codebase. A bug here affects multiple features. Full coverage ensures confidence when refactoring or adding features.

### E2E Tests: User Workflows

The home screen has **20 E2E tests** covering:

```typescript
describe('Home Screen', () => {
  describe('Basic Rendering', () => {
    // Renders title and subtitle
    // Renders all four buttons
    // Buttons have proper visual hierarchy
  });

  describe('Navigation', () => {
    // Random button navigates to /random
    // Inventory button navigates to /inventory
    // Manual selection button navigates (placeholder)
  });

  describe('Favorite Flavor Feature', () => {
    // Displays "Set Favorite" when no favorite configured
    // Button is disabled when no favorite
    // Displays flavor name when favorite configured
    // Button is enabled when favorite configured
    // Navigates when clicked (with favorite)
  });

  describe('Responsive Layout', () => {
    // Works on mobile (375px)
    // Works on tablet (768px)
    // Works on desktop (1024px)
  });

  describe('Accessibility', () => {
    // All buttons have accessible text
    // Keyboard navigation works
    // Touch targets meet 44x44px minimum
  });

  describe('Visual Polish', () => {
    // Proper spacing and layout
    // Buttons respond to hover
  });
});
```

**Why E2E instead of component tests?**

Svelte 5's runes ($derived, $state) aren't yet fully supported by @testing-library/svelte. Rather than fighting with the testing library, we use E2E tests that exercise the component in a real browser.

This also tests integration points:

- Routing (does navigation actually work?)
- State management (does the store subscription work?)
- CSS rendering (does the layout actually look right?)

**Testing responsive layout:**

```typescript
test('layout works on mobile viewport (375px)', async ({ page }) => {
  await page.setViewportSize({ width: 375, height: 667 });
  await page.goto('/#/');

  const buttons = page.locator('button');
  const randomButton = buttons.nth(0);
  const bbox = await randomButton.boundingBox();

  expect(bbox?.width).toBeGreaterThan(300); // Nearly full width
});
```

We actually resize the browser and measure elements. This catches issues like "buttons overflow on small screens" that unit tests would miss.

**Testing accessibility:**

```typescript
test('buttons have sufficient touch targets (44x44px minimum)', async ({ page }) => {
  const buttons = page.locator('button');

  for (let i = 0; i < 4; i++) {
    const bbox = await buttons.nth(i).boundingBox();
    expect(bbox?.height).toBeGreaterThanOrEqual(44);
    expect(bbox?.width).toBeGreaterThanOrEqual(44);
  }
});
```

We verify the actual rendered size, not just the CSS. This ensures touch targets are actually large enough.

## Design Trade-offs

### What We Optimized For

**Simplicity over features:**

The home screen does one thing well: navigation. We resisted adding:

- Recent selections history
- Quick stats ("12 boxes remaining")
- Settings shortcut
- Help/tutorial button

These might be valuable, but they would clutter the primary purpose. We can add them later if users need them.

**State integration over hardcoding:**

The favorite button could just navigate to a settings page. Instead, it integrates with application state to show the configured flavor name. This requires more code but provides better UX - users see what they're selecting before tapping.

**Defensive programming over crashes:**

The maybeGetFlavor utility has extensive null handling. We could assume the data is always valid (it should be, because we validate on write). But handling edge cases gracefully means the app never crashes from a corrupted favoriteFlavorId.

**E2E tests over component tests:**

Component tests would be faster and more focused. But they don't work well with Svelte 5 runes yet. E2E tests are slower but more comprehensive and avoid tool limitations.

### What We Sacrificed

**Performance for readability:**

The `$derived` runes create new objects on every state change. We could manually subscribe to the store and cache the result. But the performance impact is negligible (microseconds) and the code is much clearer.

**Flexibility for convention:**

All navigation uses the push() function and ROUTES constants. This is less flexible than inline strings but more maintainable. We chose convention over configuration.

**Feature completeness for MVP:**

The manual selection and favorite quick-pick buttons navigate to placeholder routes. They work enough to demonstrate the layout and hierarchy. Full implementation comes in later deliverables (2.4, 2.6).

## Real-World Compromises

### Emoji in Button Labels

```svelte
<Button>🎲 Random Pick</Button>
<Button>❤️ {favoriteFlavor.name}</Button>
<Button>📋 Choose Flavor</Button>
<Button>📦 Manage Inventory</Button>
```

**The compromise:** Emoji aren't accessible to screen readers and might not render consistently across platforms.

**Why we did it anyway:** For a personal utility app, the visual clarity is worth it. The buttons also have text labels, so the emoji is enhancement, not essential information. In a production app for broader audiences, we'd use icon fonts or SVG icons.

### Hard-coded Button Count

The layout assumes exactly four buttons. If we add a fifth action, we need to rethink the visual hierarchy.

**Why we did it anyway:** YAGNI (You Aren't Gonna Need It). We have clear requirements for four actions. Building a flexible "any number of buttons" system would be over-engineering. If requirements change, we refactor then.

### Mobile-Only Testing

E2E tests check three viewports (375px, 768px, 1024px) but don't test every possible size.

**Why it's okay:** We use responsive design principles (flexbox, CSS variables) that work at any size. Testing common breakpoints catches 99% of issues. Testing every pixel width would be overkill.

### LocalStorage Integration

The favorite flavor comes from localStorage (via Svelte stores). If localStorage is corrupted or unavailable, the button shows "Set Favorite" and is disabled.

**The compromise:** We don't show an error message or help text explaining why.

**Why it's okay:** This is a personal app where the user controls their data. If they haven't set a favorite, the button state makes it obvious. Adding error messaging would clutter the simple interface.

## How This Fits Into BroteinBuddy

### Navigation Hub Pattern

The home screen establishes a pattern used throughout the app:

```
Home (navigation hub)
  ├─> Random Selection (2.4)
  ├─> Favorite Quick-Pick (2.4)
  ├─> Manual Selection (2.6)
  └─> Inventory Management (2.5)
```

Every screen can return to home using the back button or explicit navigation. This creates a clear mental model: home is the starting point, all features radiate from there.

### State Integration

This is the first screen that reads application state (favoriteFlavorId, flavors). It demonstrates the pattern for later screens:

1. Import the store: `import { appState } from '$lib/stores'`
2. Subscribe with $: `$appState.favoriteFlavorId`
3. Use reactive derivation: `$derived(maybeGetFlavor(...))`

### Button Component Composition

All four buttons use the Button component from 2.1:

```svelte
<Button variant="primary" size="lg">...</Button>
<Button variant="secondary" size="base">...</Button>
<Button variant="ghost" size="base">...</Button>
```

This demonstrates component composition - building complex UIs from simple, reusable pieces. The Button component handles:

- Visual styling (variant, size)
- Hover/focus/active states
- Accessibility (ARIA attributes)
- Touch target sizing

The home screen just composes them with the right props.

### Future Extension Points

The home screen is designed for easy enhancement:

1. **Add fifth button:** Add to buttons-container, choose appropriate variant
2. **Add stats widget:** Insert before or after buttons-container
3. **Add settings button:** Place in header with absolute positioning
4. **Add animations:** Wrap buttons in transition groups

The clean structure makes these additions straightforward.

## Key Takeaways

### Mobile-First Design

1. **Start with constraints:** Design for mobile first, enhance for desktop
2. **Touch-friendly targets:** Minimum 44x44px for all interactive elements
3. **Vertical layouts:** Stack elements vertically on small screens
4. **Progressive enhancement:** Add features/spacing as viewport grows

### Reactive State Management

1. **$derived for computed values:** Automatically updates when dependencies change
2. **Store subscriptions with $:** Clean syntax for reactive store access
3. **Defensive utilities:** Handle null/undefined gracefully at boundaries
4. **Type safety:** TypeScript catches errors at compile time

### Component Architecture

1. **Single-file components:** Script, template, style in one file
2. **Component composition:** Build complex UIs from simple reusable pieces
3. **Design system integration:** Use tokens (CSS variables) for consistency
4. **Prop-based API:** Configure components with props, not global state

### Testing Strategies

1. **Unit tests for utilities:** 100% coverage on reusable functions
2. **E2E tests for workflows:** Test actual user interactions
3. **Test one behavior per test:** Descriptive names, focused assertions
4. **Test accessibility:** Touch targets, keyboard navigation, semantic HTML

### Design Patterns

1. **Visual hierarchy:** Size, color, spacing guide user attention
2. **Convention over configuration:** Consistent patterns reduce cognitive load
3. **Graceful degradation:** Handle missing data without crashing
4. **YAGNI principle:** Don't build flexibility you don't need yet

## What You Should Learn From This

### The "Maybe" Pattern

When a function might not find what it's looking for, use the "maybe" naming convention and return null:

```typescript
function maybeGetUser(id: string): User | null;
function maybeParseJson(json: string): object | null;
function maybeFindElement(selector: string): Element | null;
```

This signals to callers: "Check the result!" It's better than throwing exceptions for expected cases (like "user not found").

### Mobile-First Responsive Design

Always start with mobile:

```css
/* Base: mobile (no media query) */
.element {
  padding: 16px;
}

/* Enhancement: tablet+ */
@media (min-width: 768px) {
  .element {
    padding: 24px;
  }
}
```

This ensures mobile works even if CSS doesn't load fully. Desktop-first means mobile is broken without CSS.

### Svelte 5 Reactivity

The `$derived` rune is incredibly powerful:

```typescript
// Automatically recomputes when dependencies change
let fullName = $derived(`${firstName} ${lastName}`);
let isValid = $derived(email.includes('@') && password.length >= 8);
let filteredItems = $derived(items.filter((i) => i.active));
```

No useEffect, no useMemo, no dependency arrays. Just declare what the value should be based on other values.

### Design Systems

CSS custom properties create a design system:

```css
:root {
  --space-4: 16px;
  --color-primary: #3b82f6;
  --font-size-lg: 18px;
}
```

Then use them everywhere:

```css
.button {
  padding: var(--space-4);
  background: var(--color-primary);
  font-size: var(--font-size-lg);
}
```

Change one variable, update the entire app. This is how you scale design.

## Going Deeper

### Recommended Reading

1. **Mobile-First Design:**
   - "Mobile First" by Luke Wroblewski
   - MDN: Responsive Design Basics

2. **Svelte 5 Runes:**
   - Svelte 5 Runes RFC (official documentation)
   - Svelte Tutorial: Reactivity

3. **Component Design:**
   - "Atomic Design" by Brad Frost
   - Design Systems Handbook

4. **Accessibility:**
   - WebAIM: Touch Target Guidelines
   - MDN: Accessibility Best Practices

### Related Concepts

1. **Progressive Web Apps (PWA):** Making web apps feel native (covered in Phase 3)
2. **State Management Patterns:** Stores, actions, derived state (covered in 1.5)
3. **Client-Side Routing:** SPAs and navigation (covered in 2.2)
4. **Design Tokens:** Systematic design decisions as code

## Questions to Think About

1. **Visual Hierarchy:** How would you modify the hierarchy if "Manual Selection" was used more frequently than "Random Pick"? What would you change?

2. **Error Handling:** If loading state from localStorage failed completely, how would you communicate this to the user on the home screen?

3. **Testing Trade-offs:** Why do we have 100% coverage on maybeGetFlavor (13 lines) but test the home screen with E2E tests instead of component tests? When would you choose differently?

4. **Responsive Design:** The buttons stack vertically on all screen sizes. On a very wide screen (1920px), would a horizontal layout be better? Why or why not?

5. **State Management:** The favorite flavor is loaded reactively from the store. What happens if the user configures a favorite in another tab? Would this screen update automatically?

6. **Accessibility:** We use emoji in button labels. How could you test whether screen readers announce them properly? What would you use instead?

7. **Component Composition:** Each button calls a different handler function that just calls push() with a route. Could we eliminate the handlers and bind push() directly? What are the trade-offs?

8. **Future Features:** If you wanted to add a "Recent selections" widget to the home screen, where would you place it? Above the buttons? Below? In the header? Why?

---

## Conclusion

The home screen demonstrates that even "simple" components involve many thoughtful decisions:

- Mobile-first responsive design for accessibility across devices
- Reactive state management with Svelte 5 runes for clean, maintainable code
- Defensive programming with null-safe utilities for robustness
- Visual hierarchy through design system tokens for clear UX
- Comprehensive testing with unit and E2E tests for confidence

These patterns scale from a four-button navigation screen to complex applications. The principles are the same:

1. **Design for constraints first** (mobile, accessibility, performance)
2. **Handle edge cases gracefully** (null checks, type safety)
3. **Use the right abstractions** (components, utilities, stores)
4. **Test what matters** (user workflows, critical utilities)
5. **Keep it simple** (YAGNI, convention over configuration)

Master these fundamentals and you'll write better UI code regardless of framework or project size.
