# Modern Git Workflows: Using Worktrees for Parallel Development

## Introduction

Git worktrees are a powerful but often overlooked feature that enables developers to work on multiple branches simultaneously without the overhead of cloning a repository multiple times or constantly switching branches. This document explores worktrees in depth, with a focus on using them to enable parallel development with multiple Claude Code instances.

## What Are Git Worktrees?

A git worktree is a **linked working directory** that shares the same `.git` repository but checks out a different branch. Unlike cloning, which creates a complete copy of the repository, worktrees are lightweight and share the underlying git object database.

**Traditional workflow (branch switching):**

```bash
git checkout main
# Work on main
git checkout feature/new-feature
# Work on feature - main changes are no longer visible
```

**Worktree workflow:**

```bash
# Both branches accessible simultaneously
cd project/wt/main          # Working on main
cd ../wt/feature/new-feature  # Working on feature in parallel
```

### Key Benefits

1. **No context switching** - Keep multiple branches available simultaneously
2. **Parallel workflows** - Run tests on one branch while developing on another
3. **Shared .git database** - All worktrees share the same repository, saving disk space
4. **Independent node_modules** - Each worktree can have its own dependencies installed
5. **AI pair programming** - Multiple AI instances can work on different features without conflicts

## Worktree Organizational Patterns

There are several ways to organize worktrees, each with different trade-offs.

### 1. Sibling Structure

Worktrees live alongside the main repository:

```
~/projects/
├── my-project/         # Original clone (typically on main)
├── my-project-feature1/  # Worktree for feature/feature1
└── my-project-feature2/  # Worktree for feature/feature2
```

**Pros:**

- Simple to understand
- Familiar directory layout
- Easy to navigate from file browser

**Cons:**

- Worktrees scattered across directory
- Harder to see all worktrees at a glance
- Can clutter project parent directory

**Best for:** Small teams with occasional worktree use

### 2. Nested Structure

Worktrees organized in a subdirectory:

```
my-project/
├── .git/
├── src/
├── package.json
└── worktrees/
    ├── feature1/
    └── feature2/
```

**Pros:**

- All worktrees in one place
- Clean project root
- Easy to see what worktrees exist

**Cons:**

- Nesting can be confusing
- Path depth increases
- Main branch mixed with worktree directory

**Best for:** Projects with frequent worktree creation/deletion

### 3. Bare Repository Structure

The "purest" worktree approach - the repository itself has no working directory:

```
my-project.git/          # Bare repository (no working files)
├── config
├── objects/
└── refs/
my-project-wt/
├── main/               # Main branch worktree
├── feature1/           # Feature worktrees
└── feature2/
```

**Pros:**

- Clean separation between repository and worktrees
- All branches treated equally (no "special" main)
- Mirrors server repository structure

**Cons:**

- Less intuitive for newcomers
- Requires more setup
- Two top-level directories

**Best for:** Server-side repos, advanced users, large teams

### 4. Hybrid Structure (Used in BroteinBuddy)

Combines benefits of multiple approaches:

```
BroteinBuddy/
├── .git/               # Full repository
├── wt/                 # All worktrees
│   ├── main/
│   └── feature-*/
├── .shared/            # Shared configuration
├── init-shared.sh
└── setup-worktree.sh
```

The repository root is on a placeholder branch (`_root`), keeping the root directory clean while maintaining a traditional git repository structure.

**Pros:**

- Worktrees organized and visible (`ls wt/`)
- Easy navigation (`cd wt/feature-name`)
- Simple to find all branches
- Supports shared configuration via symlinks
- Traditional git structure (not bare)

**Cons:**

- Slightly more complex initial setup
- Requires placeholder branch at root
- Need helper scripts for consistency

**Best for:** Parallel development, multiple AI instances, teams wanting organized worktrees

## Shared Configuration with Symlinks

One challenge with worktrees is sharing configuration or context files across all branches without committing them to the repository. The hybrid structure solves this with symlinks to a shared directory.

### The Pattern

```
BroteinBuddy/
├── .shared/                       # Real files (not in git)
│   ├── CLAUDE.md
│   ├── CLAUDE_CONTEXT.md
│   ├── .planning/
│   └── .claude/
│       ├── settings.local.json
│       └── skills/               # Real directory
│           ├── skill-one.md → {external-repo}/skill-one.md
│           └── skill-two.md → {external-repo}/skill-two.md
└── wt/
    └── main/
        ├── CLAUDE.md → ../../.shared/CLAUDE.md
        ├── CLAUDE_CONTEXT.md → ../../.shared/CLAUDE_CONTEXT.md
        ├── .planning → ../../.shared/.planning
        └── .claude/
            ├── settings.local.json → ../../../.shared/.claude/settings.local.json
            └── skills → ../../../.shared/.claude/skills
```

### Why This Approach?

**Traditional approaches and their limitations:**

1. **Commit shared files to repo**
   - ❌ Confidential information leaked
   - ❌ Personal configs affect other developers
   - ❌ Every worktree update requires commits

2. **Copy files to each worktree**
   - ❌ Changes must be manually synced
   - ❌ Easy to get out of sync
   - ❌ Wastes disk space

3. **Environment variables or global configs**
   - ❌ Not project-specific
   - ❌ Hard to manage per-project settings
   - ❌ Doesn't work for multi-line content

**Symlink approach:**

- ✅ Single source of truth
- ✅ Automatic synchronization
- ✅ Keep sensitive data out of repo
- ✅ Selective inclusion via `.gitignore`

### Symlink Chain for Granular Control

BroteinBuddy uses a two-level symlink chain for skills:

```
wt/main/.claude/skills → .shared/.claude/skills/ → individual skill files
```

This provides **granular control**:

- Skills repository can contain many skills (including deprecated ones)
- Only symlinked skills are active in the project
- Add/remove skills without modifying the skills repository
- Per-project skill curation

**Example:**

```bash
# In .shared/.claude/skills/
ln -s ~/path/to/skills-repo/brotein-buddy-standards.md .
ln -s ~/path/to/skills-repo/testing-guidelines.md .
# skill-experimental.md exists in repo but not linked = not active
```

## When to Use Worktrees

### Excellent Use Cases

1. **Parallel AI Development**
   - Multiple Claude Code instances working on different features
   - Each instance has isolated working directory
   - No git conflicts between instances
   - Shared context via symlinked files

2. **Long-running branches**
   - Developing feature while maintaining hotfix branch
   - Testing changes on one branch while developing on another
   - Keeping stable branch available for demos

3. **Continuous Integration**
   - Run tests on feature branch while continuing development
   - Build multiple branches simultaneously
   - Parallel test environments

4. **Code Review**
   - Check out PR while continuing work on your branch
   - Compare implementations side-by-side
   - Test reviewer feedback without disrupting work

### When Worktrees Are Overkill

1. **Simple branch switching** - Just use `git checkout`
2. **Single-branch development** - No parallel work needed
3. **Temporary experiments** - Use `git stash` instead
4. **Very small projects** - Overhead exceeds benefits

## Comparison to Alternative Approaches

### vs. Multiple Clones

**Clones:**

```bash
git clone repo project-main
git clone repo project-feature
```

- ❌ Duplicates entire repository (wastes disk)
- ❌ Separate git databases (no shared objects)
- ❌ Must push/pull to sync between clones
- ✅ Completely independent

**Worktrees:**

- ✅ Shared git database
- ✅ All branches immediately available
- ✅ Automatic synchronization
- ⚠️ Some operations affect all worktrees

### vs. Git Submodules

**Submodules** are for embedding external repositories, not parallel development:

- Different purpose (dependency management)
- Complex update workflow
- Separate repositories entirely

**Worktrees** are for working on different branches of the same repository.

### vs. Git Subtrees

**Subtrees** merge external repositories into your history:

- Used for vendoring dependencies
- Becomes part of your repository
- Not for parallel development

**Worktrees** don't change repository history - they're just different views.

### vs. Monorepos

**Monorepos** store multiple projects in one repository:

- All code in single repo
- Shared tooling and dependencies
- Usually requires specialized tools

**Worktrees** work with any repository structure and are about workflow, not code organization.

## Best Practices

### 1. Use Helper Scripts

Automate worktree creation with consistent symlinks:

```bash
#!/bin/bash
# setup-worktree.sh
git worktree add "wt/$1" "$1"
cd "wt/$1"
ln -s ../../.shared/CLAUDE.md .
# ... more symlinks
npm install
```

### 2. Document the Structure

In `CONTRIBUTING.md`, explain:

- Why worktrees are used
- How to create new worktrees
- What shared files exist and their purpose
- How to clean up worktrees

### 3. Add Worktrees to .gitignore

```gitignore
/wt/
/.shared/
```

Prevents accidentally committing worktree directories or shared files.

### 4. Clean Up Regularly

Remove worktrees when done:

```bash
git worktree remove wt/feature-name
git branch -d feature-name
```

List current worktrees:

```bash
git worktree list
```

### 5. Be Aware of Shared State

Some git operations affect all worktrees:

- **Branches** - Deleting a branch removes it everywhere
- **Refs** - Tags and refs are shared
- **Config** - Repository config affects all worktrees
- **Stash** - Stash is shared across worktrees

## Implementation Notes for BroteinBuddy

### Why the Hybrid Approach?

BroteinBuddy uses the hybrid structure to enable:

1. **Multiple Claude Code instances** working simultaneously
2. **Shared context** via symlinked CLAUDE.md and configuration
3. **Organized workspace** with all worktrees in `wt/`
4. **Easy navigation** between branches

### The Placeholder Branch Trick

The repository root sits on a `_root` branch that exists solely to keep the root directory clean. All actual work happens in worktrees under `wt/`.

This provides:

- Clean root directory (only scripts and shared folder)
- Traditional git structure (not bare)
- Clear mental model (root = scripts, wt/ = work)

### Scripts as First-Class Citizens

`init-shared.sh` and `setup-worktree.sh` are committed to the repository, making the worktree workflow reproducible and documented.

## Conclusion

Git worktrees are a powerful tool for managing parallel development workflows. While they add some complexity, the benefits for use cases like multi-instance AI development or long-running branches far outweigh the overhead.

The hybrid organizational structure with symlinked shared configuration provides the best of both worlds: organized worktrees with shared context, enabling truly parallel development without conflicts.

## Further Reading

- [Git Worktree Documentation](https://git-scm.com/docs/git-worktree)
- [Git Worktree Tutorial](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging)
- [BroteinBuddy CONTRIBUTING.md](../CONTRIBUTING.md) for project-specific workflow
