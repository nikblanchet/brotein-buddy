# Type-Driven Design: Using TypeScript Interfaces to Define Your Domain Model

**Deliverable:** Phase 1, Deliverable 1.1 - Data Model Definition & TypeScript Interfaces

**Created:** 2025-10-26

---

## Introduction

Type-driven design is a software development approach where you begin by defining the types that represent your domain model before writing any implementation code. In TypeScript, this means creating interfaces that capture the structure, constraints, and relationships of your data.

This document explains the philosophy, benefits, and best practices of type-driven design, using BroteinBuddy's data model as a concrete example.

## What is Type-Driven Design?

Type-driven design is the practice of:

1. **Starting with types** - Define interfaces before implementation
2. **Encoding constraints** - Use the type system to enforce rules
3. **Documenting intent** - Let types serve as self-documenting code
4. **Leveraging tooling** - Get compile-time checks and IDE support

### The Traditional Approach

In traditional development, you might start with implementation:

```typescript
// Start with code first
function addBox(boxes, box) {
  boxes.push(box);
}

// What is a box? What fields does it have? We have to guess or read docs.
```

Problems:

- No clarity on data structure
- Easy to make mistakes (wrong property names, missing fields)
- Refactoring is risky
- IDE can't help you

### The Type-Driven Approach

With type-driven design, you start with interfaces:

```typescript
// Define the types first
interface Box {
  id: string;
  flavorId: string;
  quantity: number;
  location: Location;
  isOpen: boolean;
}

// Now implementation is clear and safe
function addBox(boxes: Box[], box: Box): void {
  boxes.push(box);
}
```

Benefits:

- Clear data structure from the start
- TypeScript catches errors at compile time
- IDE autocomplete works perfectly
- Refactoring is safe (compiler finds all usages)

## The BroteinBuddy Data Model: A Case Study

Let's walk through how we applied type-driven design to BroteinBuddy's data model.

### Step 1: Identify Domain Concepts

Before writing any code, we identified the core domain concepts:

- **Flavors** - Types of protein shakes (Chocolate, Vanilla, etc.)
- **Boxes** - Physical containers holding bottles of one flavor
- **Locations** - Where boxes are stored physically
- **Application State** - The complete state of the app

### Step 2: Define Simple Types First

Start with the simplest, most fundamental types:

```typescript
/**
 * Represents a 2D coordinate position in the physical storage system.
 */
interface Location {
  stack: number; // Horizontal position (which column)
  height: number; // Vertical position (how many boxes from ground)
}
```

Why this is good:

- Clear purpose (JSDoc comment)
- Simple structure (just two numbers)
- Self-explanatory field names
- No dependencies on other types

### Step 3: Build Up Complexity

Next, define types that depend on the simple ones:

```typescript
/**
 * Represents a physical box of protein shakes in inventory.
 */
interface Box {
  id: string;
  flavorId: string; // Reference to Flavor.id
  quantity: number; // Number of bottles (>= 0)
  location: Location; // Uses the Location type we defined
  isOpen: boolean;
}
```

Key decisions:

- **Use IDs for relationships**: `flavorId` instead of embedding the whole Flavor object
- **Document constraints**: "quantity >= 0" tells readers about validation rules
- **Compose types**: `location: Location` reuses the type we already defined

### Step 4: Define the Root State

Finally, create the top-level state that ties everything together:

```typescript
/**
 * Complete application state containing all data.
 */
interface AppState {
  boxes: Box[];
  flavors: Flavor[];
  favoriteFlavorId: string | null;
  settings: Settings;
}
```

Why this works:

- Arrays of typed objects (`Box[]`, `Flavor[]`)
- Nullable types (`string | null`) make optionality explicit
- Everything is in one place for easy serialization

## Benefits of Type-Driven Design

### 1. Compile-Time Safety

TypeScript catches errors before runtime:

```typescript
const box: Box = {
  id: 'box_001',
  flavorId: 'flavor_001',
  quantity: 12,
  location: { stack: 0, height: 0 },
  // Missing isOpen - TypeScript error!
};
```

Without types, this would fail at runtime (or cause subtle bugs).

### 2. IDE Superpowers

Your editor becomes incredibly helpful:

- **Autocomplete**: Type `box.` and see all available fields
- **Go to definition**: Click `Box` to see the interface
- **Find all references**: Rename `quantity` safely everywhere
- **Inline documentation**: JSDoc appears in tooltips

### 3. Self-Documenting Code

Good interfaces tell you what the code does:

```typescript
// This signature tells you everything
function selectPriorityBox(boxes: Box[], flavorId: string): Box | null;
```

You know:

- Input: array of boxes and a flavor ID
- Output: either a Box or null (if none found)
- No need to read implementation to understand usage

### 4. Safe Refactoring

Want to rename `isOpen` to `opened`? With types:

1. Rename in the interface
2. TypeScript shows all broken code
3. Fix each one
4. Done - guaranteed no missed spots

Without types:

1. Find and replace (hope you got them all)
2. Test extensively
3. Still might miss edge cases

### 5. Design Clarity

Writing types first forces you to think through design:

- What fields does each entity need?
- How do entities relate to each other?
- What constraints exist?
- What can be null/undefined?

This clarity early prevents rework later.

## Type Guards: Bridging Runtime and Compile-Time

TypeScript types only exist at compile time. At runtime, everything is just JavaScript. How do you validate data from untrusted sources (like LocalStorage)?

**Type guards** are functions that check runtime values and tell TypeScript what type they are:

```typescript
function isBox(value: unknown): value is Box {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'flavorId' in value &&
    'quantity' in value &&
    'location' in value &&
    'isOpen' in value &&
    typeof (value as Box).id === 'string' &&
    typeof (value as Box).flavorId === 'string' &&
    typeof (value as Box).quantity === 'number' &&
    typeof (value as Box).isOpen === 'boolean' &&
    (value as Box).quantity >= 0 &&
    Number.isInteger((value as Box).quantity) &&
    isLocation((value as Box).location)
  );
}
```

Usage:

```typescript
// Load from LocalStorage (untrusted data)
const data = JSON.parse(localStorage.getItem('appState'));

// Validate with type guard
if (isAppState(data)) {
  // TypeScript knows data is AppState here
  console.log(data.boxes.length);
} else {
  // Invalid data - use default
  const defaultState = createDefaultAppState();
}
```

Benefits:

- **Runtime safety**: Catch corrupted data early
- **Type narrowing**: TypeScript trusts the type guard
- **Validation**: Enforce constraints (quantity >= 0)
- **Graceful degradation**: Return defaults on failure

## Best Practices

### 1. Write JSDoc Comments

Good documentation is part of good types:

````typescript
/**
 * Represents a protein shake flavor that can be tracked in inventory.
 *
 * @example
 * ```typescript
 * const chocolateFlavor: Flavor = {
 *   id: 'flavor_001',
 *   name: 'Chocolate',
 *   excludeFromRandom: false
 * };
 * ```
 *
 * @remarks
 * - IDs should be unique across all flavors
 * - Name is user-facing and can be changed
 * - excludeFromRandom allows users to prevent certain flavors from
 *   appearing in random selection
 */
interface Flavor {
  id: string;
  name: string;
  excludeFromRandom: boolean;
}
````

Include:

- Purpose of the type
- Examples showing usage
- Important constraints or rules
- Relationships to other types

### 2. Make Constraints Explicit

Use TypeScript features to encode rules:

```typescript
// Bad: quantity could be negative
quantity: number;

// Better: document the constraint
/** Number of bottles (must be >= 0) */
quantity: number;

// Best: enforce in type guard
function isBox(value: unknown): value is Box {
  // ...
  (value as Box).quantity >= 0;
  // ...
}
```

### 3. Use Union Types for Optionality

Be explicit about what can be null/undefined:

```typescript
// Bad: unclear if this can be null
favoriteFlavorId: string;

// Good: explicitly nullable
favoriteFlavorId: string | null;
```

### 4. Compose Types

Build complex types from simple ones:

```typescript
// Simple types
interface Location {
  stack: number;
  height: number;
}

interface Flavor {
  id: string;
  name: string;
}

// Composed type
interface Box {
  id: string;
  flavorId: string;
  quantity: number;
  location: Location; // Reuses Location
  isOpen: boolean;
}

// Top-level composition
interface AppState {
  boxes: Box[]; // Array of Boxes
  flavors: Flavor[]; // Array of Flavors
  favoriteFlavorId: string | null;
  settings: Settings;
}
```

Benefits:

- **Modularity**: Change Location without touching Box
- **Reusability**: Location can be used elsewhere
- **Clarity**: Each type has single responsibility

### 5. Prefer Interfaces Over Type Aliases for Objects

For object shapes, use interfaces:

```typescript
// Prefer this
interface Box {
  id: string;
  quantity: number;
}

// Over this
type Box = {
  id: string;
  quantity: number;
};
```

Why:

- Better error messages
- Can be extended/implemented
- Clearer intent (this is an object shape)

Use type aliases for unions, intersections, and primitives:

```typescript
type BoxId = string;
type Result = Success | Failure;
```

### 6. Write Tests for Type Guards

Type guards are runtime code - test them:

```typescript
describe('isBox', () => {
  it('returns true for valid Box', () => {
    const validBox: Box = {
      id: 'box_001',
      flavorId: 'flavor_001',
      quantity: 12,
      location: { stack: 0, height: 0 },
      isOpen: false,
    };
    expect(isBox(validBox)).toBe(true);
  });

  it('returns false for negative quantity', () => {
    const invalidBox = {
      id: 'box_001',
      flavorId: 'flavor_001',
      quantity: -1, // Invalid!
      location: { stack: 0, height: 0 },
      isOpen: false,
    };
    expect(isBox(invalidBox)).toBe(false);
  });
});
```

Target 100% coverage for type guards - they're critical paths.

## Common Pitfalls and How to Avoid Them

### Pitfall 1: Over-Engineering Types Early

**Problem:**

```typescript
// Too complex for v1
interface Location {
  room: 'garage' | 'pantry' | 'bedroom';
  stack: number;
  height: number;
  zone?: string;
  metadata?: Record<string, unknown>;
}
```

**Solution:** Start simple, extend later:

```typescript
// Good for v1
interface Location {
  stack: number;
  height: number;
}

// Can extend later if needed
interface Location {
  stack: number;
  height: number;
  room?: string; // Added in v2
}
```

### Pitfall 2: Forgetting Runtime Validation

**Problem:**

```typescript
// Assumes data is valid
const state: AppState = JSON.parse(localStorage.getItem('state'));
// Crashes if data is corrupted!
```

**Solution:** Always validate external data:

```typescript
const data = JSON.parse(localStorage.getItem('state'));
if (isAppState(data)) {
  // Safe to use
} else {
  // Use default
  const state = createDefaultAppState();
}
```

### Pitfall 3: Embedding Instead of Referencing

**Problem:**

```typescript
// Box embeds the entire Flavor
interface Box {
  id: string;
  flavor: Flavor; // Duplication!
  quantity: number;
}
```

Issues:

- Changing flavor name requires updating all boxes
- Larger JSON payload
- Data duplication

**Solution:** Use IDs (normalized structure):

```typescript
// Box references Flavor by ID
interface Box {
  id: string;
  flavorId: string; // Reference
  quantity: number;
}
```

### Pitfall 4: Unclear Null vs Undefined

**Problem:**

```typescript
// What does missing favoriteFlavorId mean?
interface AppState {
  favoriteFlavorId: string;
}
```

**Solution:** Be explicit:

```typescript
// Clear: null means "not set yet"
interface AppState {
  favoriteFlavorId: string | null;
}
```

## The Type-Driven Design Workflow

Here's the step-by-step process we used for BroteinBuddy:

### 1. Understand the Domain

Ask questions:

- What are the core entities?
- How do they relate?
- What constraints exist?
- What can change over time?

### 2. Write Interfaces

Start with simple types, build up to complex ones:

```
Location (simple) → Flavor (simple) → Box (uses Location) → AppState (uses all)
```

### 3. Add Documentation

Write comprehensive JSDoc:

- Purpose
- Examples
- Constraints
- Relationships

### 4. Create Type Guards

For anything loaded from external sources (LocalStorage, API, files):

```typescript
(isLocation(), isFlavor(), isBox(), isAppState());
```

### 5. Write Tests

Test the type guards thoroughly:

- Valid data
- Invalid data
- Edge cases
- Boundary conditions

### 6. Document Decisions

Write an ADR explaining:

- Why these types?
- What alternatives were considered?
- What trade-offs were made?

### 7. Implement Features

Now write the actual application code, using the types:

```typescript
function addBox(state: AppState, box: Box): AppState {
  // TypeScript ensures this is correct
  return {
    ...state,
    boxes: [...state.boxes, box],
  };
}
```

## Conclusion

Type-driven design is a powerful approach that provides:

- **Safety**: Catch errors at compile time
- **Clarity**: Types document intent
- **Productivity**: IDE support is incredible
- **Confidence**: Refactoring is safe

The key insight is to **think about types first**, before implementation. This up-front design work pays dividends throughout the project lifecycle.

In BroteinBuddy, our type-driven approach gave us:

- 100% test coverage on type guards
- Clear, self-documenting code
- Safe refactoring capabilities
- Excellent IDE support
- Runtime validation of external data

Whether you're building a small PWA or a large application, type-driven design helps you write better, more maintainable code.

## Further Reading

- [TypeScript Handbook: Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
- [TypeScript Handbook: Type Guards and Type Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
- [Domain-Driven Design](https://www.domainlanguage.com/ddd/) by Eric Evans
- [BroteinBuddy ADR-002: Data Model Design](../adr/002-data-model-design.md)
- [BroteinBuddy src/types/models.ts](../../src/types/models.ts)

---

**Next Teaching Document:** 1.2 - Web Storage Best Practices (upcoming with Deliverable 1.2)
