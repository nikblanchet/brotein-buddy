# Weighted Random Selection: Algorithms and Statistical Testing

This document explains the weighted random selection algorithm used in BroteinBuddy, covering the mathematical foundation, implementation approach, and comprehensive testing strategy.

## Context

In BroteinBuddy, users want a random flavor selector that accounts for inventory quantities. A flavor with 60 bottles should be selected more often than a flavor with only 10 bottles. This creates a more realistic "random" experience that naturally uses up larger quantities faster.

## The Challenge

Simple random selection treats all options equally. If you have 3 flavors, each gets a 33.3% chance regardless of quantity. But we want probability proportional to quantity.

### Example Scenario

```
Chocolate: 60 bottles (across 2 boxes: 40 + 20)
Vanilla:   30 bottles (across 1 box)
Strawberry: 10 bottles (across 2 boxes: 5 + 5)
Total:     100 bottles
```

**Desired probabilities:**

- Chocolate: 60%
- Vanilla: 30%
- Strawberry: 10%

## Algorithm Design

### 1. Calculate Total Quantities

First, sum the quantity across all boxes for each flavor:

```typescript
const quantityByFlavorId = new Map<string, number>();

for (const box of state.boxes) {
  const currentQty = quantityByFlavorId.get(box.flavorId) || 0;
  quantityByFlavorId.set(box.flavorId, currentQty + box.quantity);
}
```

**Why a Map?** O(1) lookup time. We'll access these quantities multiple times.

**Time complexity:** O(n) where n = number of boxes.

### 2. Filter Invalid Flavors

Remove flavors that shouldn't be selected:

```typescript
const validFlavors = state.flavors.filter((flavor) => {
  // User explicitly excluded this flavor
  if (flavor.excludeFromRandom) return false;

  // Prevent consecutive repeats
  if (excludeLastPick !== undefined && flavor.id === excludeLastPick) {
    return false;
  }

  // Out of stock
  const totalQty = quantityByFlavorId.get(flavor.id) || 0;
  if (totalQty === 0) return false;

  return true;
});
```

**Important:** Check for zero quantity AFTER summing across boxes. A flavor might have 3 boxes, all with 0 quantity.

### 3. Handle Edge Case

```typescript
if (validFlavors.length === 0) {
  return null;
}
```

Returning `null` lets the UI show "No flavors available" instead of crashing.

### 4. Weighted Random Selection

This is the core algorithm. There are several approaches:

#### Approach A: Array Method (Not Used)

Create an array with entries repeated by weight, then random pick:

```typescript
// DON'T DO THIS - memory inefficient
const weightedArray = [];
for (const flavor of validFlavors) {
  const qty = quantityByFlavorId.get(flavor.id) || 0;
  for (let i = 0; i < qty; i++) {
    weightedArray.push(flavor);
  }
}
return weightedArray[Math.floor(Math.random() * weightedArray.length)];
```

**Problem:** If you have 10,000 bottles, this creates a 10,000-element array. Terrible memory usage.

#### Approach B: Cumulative Sum (Used in BroteinBuddy)

Calculate the total weight, pick a random value in that range, then walk through flavors subtracting weights until you find the selection:

```typescript
// Calculate total weight
const totalWeight = validFlavors.reduce((sum, flavor) => {
  return sum + (quantityByFlavorId.get(flavor.id) || 0);
}, 0);

// Pick random point in range [0, totalWeight)
let randomValue = Math.random() * totalWeight;

// Walk through, subtracting weights
for (const flavor of validFlavors) {
  const weight = quantityByFlavorId.get(flavor.id) || 0;
  randomValue -= weight;

  if (randomValue <= 0) {
    return flavor;
  }
}

// Defensive fallback (floating point edge case)
return validFlavors[validFlavors.length - 1];
```

**Why this works:**

Imagine a number line from 0 to 100:

```
[---- Chocolate (0-60) ----][-- Vanilla (60-90) --][- Straw (90-100) -]
```

If `Math.random() * 100` returns:

- 0-60: Select Chocolate
- 60-90: Select Vanilla
- 90-100: Select Strawberry

The loop walks this line:

1. Start with random value (e.g., 75)
2. Subtract Chocolate's weight (60): `75 - 60 = 15`
3. Still positive, continue
4. Subtract Vanilla's weight (30): `15 - 30 = -15`
5. Negative! Return Vanilla

**Complexity:**

- Time: O(m) where m = number of valid flavors (typically small, <10)
- Space: O(1) additional space (just the randomValue variable)

#### Approach C: Binary Search with Cumulative Array

Build a cumulative sum array, then binary search:

```typescript
// Build cumulative sums
const cumulative = [0];
for (const flavor of validFlavors) {
  const weight = quantityByFlavorId.get(flavor.id) || 0;
  cumulative.push(cumulative[cumulative.length - 1] + weight);
}

// Random pick
const randomValue = Math.random() * cumulative[cumulative.length - 1];

// Binary search for the index
// ... binary search code ...
```

**When to use:** If you have hundreds of flavors. For 5-10 flavors, the overhead of binary search isn't worth it.

**BroteinBuddy choice:** Use Approach B. Simple, efficient for our scale, easy to understand and test.

## Testing Strategy

### Basic Functionality Tests

Verify the function handles expected inputs correctly:

```typescript
it('should return the only available flavor', () => {
  // Setup state with 1 flavor, 1 box
  // Call selectRandomFlavor(state)
  // Expect: returns that flavor
});

it('should return null when no flavors available', () => {
  // Setup state with no boxes or all excluded
  // Call selectRandomFlavor(state)
  // Expect: returns null
});
```

**Why?** Catch obvious bugs early. These run fast.

### Filter Tests

Verify each filter works independently:

```typescript
it('should not select flavors marked with excludeFromRandom', () => {
  // Setup: Chocolate (normal), Vanilla (excluded)
  // Run 50 times
  // Expect: Always returns Chocolate, never Vanilla
});

it('should not select the flavor specified in excludeLastPick', () => {
  // Setup: Chocolate, Vanilla (both normal)
  // Call with excludeLastPick = 'chocolate'
  // Run 50 times
  // Expect: Always returns Vanilla
});
```

**Why run 50 times?** If the code is buggy and returns a random flavor without filtering, there's a chance it accidentally returns the correct answer once. Running 50 times makes a bug statistically impossible to miss (probability of false pass: 0.5^50 ≈ 0).

### Combined Filter Tests

Verify filters work together:

```typescript
it('should apply both excludeFromRandom and excludeLastPick', () => {
  // Setup: Chocolate, Vanilla (excluded by flag), Strawberry
  // Call with excludeLastPick = 'chocolate'
  // Expect: Only Strawberry is valid
});
```

**Why?** Filters might work individually but interfere with each other. Test the combinations.

### Statistical Distribution Tests

This is the most important test for a weighted random algorithm:

```typescript
it('should select flavors proportional to their total quantity', () => {
  // Setup: Chocolate (60), Vanilla (30), Strawberry (10)
  const counts = { chocolate: 0, vanilla: 0, strawberry: 0 };

  for (let i = 0; i < 1000; i++) {
    const result = selectRandomFlavor(state);
    counts[result.id]++;
  }

  // Check percentages with tolerance
  expect(counts.chocolate / 1000).toBeGreaterThan(0.5);
  expect(counts.chocolate / 1000).toBeLessThan(0.7);
  // ... similar for vanilla and strawberry
});
```

**Key decisions:**

1. **How many iterations?**
   - Too few (10): High variance, test is flaky
   - Too many (100,000): Slow tests, CI/CD takes forever
   - Sweet spot (1,000): Good balance

2. **Tolerance percentage?**
   - Expected: 60%
   - Tolerance: ±10% (50-70%)
   - Why 10%? With 1,000 iterations, standard deviation is small enough that ±10% catches bugs while avoiding false failures

3. **Why not exact?**
   - Random processes have variance
   - A perfect 60.0% in 1,000 runs is suspicious (maybe not random?)
   - Accept range that reflects natural variance

**Statistical note:** With 1,000 samples and true probability of 60%, the standard deviation is approximately:

```
σ = sqrt(n * p * (1-p)) = sqrt(1000 * 0.6 * 0.4) ≈ 15.5
```

So 95% confidence interval is roughly 60% ± 3%. Our ±10% tolerance is conservative.

### Edge Case Tests

```typescript
it('should handle single box with quantity 1', () => {
  // Minimum valid state
});

it('should handle very large quantities', () => {
  // Ensure no integer overflow or floating point issues
});

it('should sum quantities across multiple boxes of same flavor', () => {
  // Verify the summing logic works
});
```

**Why?** Edge cases often reveal off-by-one errors, overflow bugs, or incorrect assumptions.

## Common Pitfalls and Solutions

### Pitfall 1: Counting Boxes Instead of Quantities

**Wrong:**

```typescript
// Flavor with 3 boxes gets triple weight, even if total qty is same
const weight = state.boxes.filter((b) => b.flavorId === flavor.id).length;
```

**Correct:**

```typescript
// Weight by total quantity across all boxes
const weight = state.boxes
  .filter((b) => b.flavorId === flavor.id)
  .reduce((sum, b) => sum + b.quantity, 0);
```

### Pitfall 2: Not Handling Empty Flavors

**Wrong:**

```typescript
// Crash if flavor has no boxes
const weight = quantityByFlavorId.get(flavor.id); // might be undefined
randomValue -= weight; // NaN propagates
```

**Correct:**

```typescript
const weight = quantityByFlavorId.get(flavor.id) || 0;
```

### Pitfall 3: Off-By-One in Random Range

**Wrong:**

```typescript
// Exclusive range, but using floor means never reaches totalWeight
const index = Math.floor(Math.random() * totalWeight);
```

**Correct for our algorithm:**

```typescript
// Continuous value in [0, totalWeight)
const randomValue = Math.random() * totalWeight;
```

We use a continuous value and subtract weights, not an integer index.

### Pitfall 4: Forgetting the Fallback

**Wrong:**

```typescript
for (const flavor of validFlavors) {
  randomValue -= weight;
  if (randomValue <= 0) return flavor;
}
// What if we exit the loop? (floating point precision edge case)
```

**Correct:**

```typescript
for (const flavor of validFlavors) {
  randomValue -= weight;
  if (randomValue <= 0) return flavor;
}
// Defensive fallback
return validFlavors[validFlavors.length - 1];
```

The fallback should theoretically never execute, but floating point arithmetic can have edge cases. Better safe than crashing.

## Complexity Analysis

Given:

- n = number of boxes
- m = number of flavors
- v = number of valid flavors (after filtering)

**Time Complexity:**

1. Calculate quantities: O(n) - iterate all boxes
2. Filter flavors: O(m) - iterate all flavors, each does O(1) Map lookup
3. Calculate total weight: O(v) - iterate valid flavors
4. Weighted selection: O(v) - iterate valid flavors until selection

**Total: O(n + m + v)**

Since v ≤ m, this simplifies to: **O(n + m)**

In practice:

- n ≈ 10-50 boxes
- m ≈ 5-20 flavors
- Total: <100 operations

Extremely fast. No optimization needed.

**Space Complexity:**

- Quantity map: O(m)
- Valid flavors array: O(m)

**Total: O(m)**

Again, negligible for our use case.

## Comparison with Alternatives

### Alternative 1: Select Random Box, Then Use Its Flavor

**Approach:**

```typescript
const boxesWithQuantity = state.boxes.filter((b) => b.quantity > 0);
const randomBox = boxesWithQuantity[Math.floor(Math.random() * boxesWithQuantity.length)];
return state.flavors.find((f) => f.id === randomBox.flavorId);
```

**Problem:** Each box gets equal probability, not each bottle. If Chocolate has 1 box of 60 bottles and Vanilla has 6 boxes of 5 bottles each, they have equal probability even though Chocolate has 2x quantity.

**When to use:** If you want to select a random box, not a random flavor.

### Alternative 2: Reservoir Sampling

**When to use:** When you're streaming data and don't know the total count upfront.

**BroteinBuddy context:** We have all data in memory. No need for reservoir sampling complexity.

### Alternative 3: Alias Method

**Approach:** Precompute a lookup table for O(1) selection.

**Setup time:** O(m)
**Selection time:** O(1)

**When to use:** If you're calling the selection function millions of times per second.

**BroteinBuddy context:** User taps "Random" button maybe 10 times per day. Setup overhead not worth it.

## Lessons Learned

1. **Design for your scale:** Don't over-engineer. BroteinBuddy has <20 flavors. Simple algorithms work great.

2. **Test statistical properties:** For random algorithms, run the function many times and verify the distribution, not just single outputs.

3. **Use appropriate tolerances:** Don't expect exactly 60.000% in 1,000 trials. Account for natural variance.

4. **Defensive programming:** Add the fallback return statement even if you think it's unreachable.

5. **Document edge cases:** Comment why the fallback exists, even if coverage tools say it's unreachable.

## References and Further Reading

- **Weighted Random Selection:** Used in game development (loot drops), advertising (ad selection), ML (sampling).
- **Alternative Algorithms:** Alias Method, Vose's Alias Method (for very high performance).
- **Testing Random Functions:** "Foundations of Software Testing" by Aditya P. Mathur, Chapter 8 (Statistical Testing).
- **Floating Point Arithmetic:** "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David Goldberg.

## Implementation Checklist

When implementing weighted random selection in any project:

- [ ] Clarify what "weight" means (box count vs quantity vs something else)
- [ ] Handle zero-weight items (filter out or allow?)
- [ ] Handle empty input (return null, throw error, or return default?)
- [ ] Decide on algorithm based on scale (simple cumulative for <100 items, Alias Method for millions)
- [ ] Write statistical distribution tests with appropriate tolerance
- [ ] Document the algorithm and assumptions
- [ ] Consider whether you need reproducibility (seeded random for testing)

## Conclusion

Weighted random selection is a powerful tool for creating realistic random experiences. The cumulative sum approach is simple, efficient, and easy to test. Statistical testing is essential to verify correctness since individual runs look random regardless of whether the weighting is correct.

For BroteinBuddy, this algorithm creates a natural inventory rotation where high-quantity flavors get used more often, providing a better user experience than pure random selection.
