# Svelte Stores: Reactive State Management and LocalStorage Integration

**Deliverable:** 1.5 - State Management with Svelte Stores
**Author:** Claude Code
**Date:** 2025-10-27
**Skill Level:** Intermediate

---

## Table of Contents

1. [Introduction](#introduction)
2. [What Are Svelte Stores?](#what-are-svelte-stores)
3. [Store Types and When to Use Them](#store-types-and-when-to-use-them)
4. [The Subscription Pattern and Reactivity](#the-subscription-pattern-and-reactivity)
5. [Building Our Store: Design Decisions](#building-our-store-design-decisions)
6. [Auto-Save with Subscriptions](#auto-save-with-subscriptions)
7. [Action Pattern for Mutations](#action-pattern-for-mutations)
8. [Immutability and Spread Operators](#immutability-and-spread-operators)
9. [Error Handling Strategies](#error-handling-strategies)
10. [Testing Stores with Vitest](#testing-stores-with-vitest)
11. [Common Pitfalls and How to Avoid Them](#common-pitfalls-and-how-to-avoid-them)
12. [Performance Considerations](#performance-considerations)
13. [When to Use Context vs Stores](#when-to-use-context-vs-stores)
14. [Future Enhancements](#future-enhancements)
15. [References and Further Reading](#references-and-further-reading)

---

## Introduction

State management is one of the most critical aspects of modern web applications. You need a way to share data between components, keep the UI in sync with that data, and persist changes so users don't lose their work. Get it wrong, and you end up with bugs that are hard to track down, UI inconsistencies, and frustrated users.

Svelte makes state management surprisingly simple with its built-in store system. Unlike React or Vue, which often require external libraries like Redux or Pinia, Svelte's stores are part of the framework and integrate seamlessly with its reactivity system.

This document teaches you how to build robust state management using Svelte stores, with real-world examples from the BroteinBuddy project where we manage an inventory of protein shake boxes.

### Learning Objectives

By the end of this document, you will understand:

- What Svelte stores are and why they're useful
- The differences between writable, readable, and derived stores
- How the subscription pattern enables reactivity
- Techniques for automatically persisting state to LocalStorage
- The action pattern for organizing state mutations
- Why immutability matters and how to maintain it
- Error handling strategies for storage operations
- How to test stores thoroughly
- Common mistakes and how to avoid them
- When to use stores vs Svelte's context API

### Prerequisites

- Basic Svelte knowledge (components, reactivity)
- TypeScript familiarity
- Understanding of LocalStorage (covered in teaching doc 1.2)
- Knowledge of type guards (covered in teaching doc 1.1)

---

## What Are Svelte Stores?

At their core, Svelte stores are objects that hold values and notify subscribers when those values change. Think of them as observable values that multiple components can watch and react to.

Here's the simplest possible example:

```typescript
import { writable } from 'svelte/store';

// Create a store holding a number
const count = writable(0);

// Subscribe to changes
count.subscribe((value) => {
  console.log('Count is now:', value);
});
// Output: "Count is now: 0"

// Update the value
count.set(5);
// Output: "Count is now: 5"

// Update based on current value
count.update((n) => n + 1);
// Output: "Count is now: 6"
```

That's it. That's a store. But the real magic happens when you use stores in Svelte components:

```svelte
<script>
  import { count } from './stores';

  function increment() {
    count.update((n) => n + 1);
  }
</script>

<!-- The $ prefix auto-subscribes and auto-unsubscribes -->
<p>Count: {$count}</p>
<button on:click={increment}>Increment</button>
```

The `$` prefix is syntactic sugar that:

1. Automatically subscribes to the store when the component mounts
2. Updates the value whenever the store changes
3. Automatically unsubscribes when the component is destroyed

No manual subscription management. No memory leaks from forgotten unsubscribes. It just works.

### Why Use Stores?

You might be wondering: "Can't I just use component props to pass data around?" You can, but that gets messy fast:

**Without stores (prop drilling):**

```svelte
<!-- App.svelte -->
<script>
  let user = { name: 'Alice' };
</script>

<Header {user} />
<MainContent {user} />
<Footer {user} />

<!-- Now Header needs to pass user to Nav, which passes to Profile... -->
```

Every component in the chain needs to accept and pass the `user` prop, even if they don't use it themselves. This is called "prop drilling" and it's tedious and error-prone.

**With stores:**

```typescript
// stores.ts
export const user = writable({ name: 'Alice' });
```

```svelte
<!-- Profile.svelte - anywhere in the tree -->
<script>
  import { user } from './stores';
</script>

<p>Hello, {$user.name}!</p>
```

Any component can import and use the store directly. No prop drilling. No intermediate components acting as pass-throughs.

---

## Store Types and When to Use Them

Svelte provides three types of stores, each serving different purposes.

### 1. Writable Stores

Writable stores can be read from and written to. They're the most common type.

```typescript
import { writable } from 'svelte/store';

const count = writable(0);

// Three methods available:
count.set(5); // Set to specific value
count.update((n) => n + 1); // Update based on current value
count.subscribe((value) => console.log(value)); // Watch for changes
```

**Use writable stores when:**

- Multiple components need to read AND modify the same data
- You're managing application state that changes over time
- You need full control over when and how values change

**BroteinBuddy example:** Our `appState` store is writable because the UI needs to add boxes, remove boxes, update quantities, etc.

### 2. Readable Stores

Readable stores can only be read from, not written to. They're useful for values that come from external sources.

```typescript
import { readable } from 'svelte/store';

// Clock that updates every second
const time = readable(new Date(), (set) => {
  const interval = setInterval(() => {
    set(new Date());
  }, 1000);

  // Cleanup function (called when last subscriber unsubscribes)
  return () => clearInterval(interval);
});
```

The second argument is a "start" function that runs when the first subscriber subscribes. It receives a `set` function to update the value, and returns a "stop" function for cleanup.

**Use readable stores when:**

- Data comes from external sources (timers, WebSockets, sensors)
- You want to prevent components from modifying the value
- You need to set up/tear down resources based on subscription

**Examples:**

- Current time or date
- Geolocation updates
- WebSocket connection state
- Mouse position

### 3. Derived Stores

Derived stores compute their value from one or more other stores. They update automatically when their dependencies change.

```typescript
import { writable, derived } from 'svelte/store';

const boxes = writable([
  { flavorId: 'chocolate', quantity: 12 },
  { flavorId: 'vanilla', quantity: 8 },
  { flavorId: 'chocolate', quantity: 6 },
]);

// Automatically recomputes when boxes changes
const totalQuantity = derived(boxes, ($boxes) => {
  return $boxes.reduce((sum, box) => sum + box.quantity, 0);
});

totalQuantity.subscribe((value) => console.log('Total:', value));
// Output: "Total: 26"
```

**Use derived stores when:**

- You need to compute values based on other stores
- Multiple components need the same computed value
- You want to avoid duplicating computation logic

**BroteinBuddy examples (we'll add these in Phase 2):**

```typescript
// Total quantity per flavor
const quantityByFlavor = derived(appState, ($state) => {
  const totals = new Map<string, number>();
  for (const box of $state.boxes) {
    const current = totals.get(box.flavorId) || 0;
    totals.set(box.flavorId, current + box.quantity);
  }
  return totals;
});

// All open boxes
const openBoxes = derived(appState, ($state) => $state.boxes.filter((box) => box.isOpen));

// Flavors available for random selection
const selectableFlavors = derived(appState, ($state) => {
  return $state.flavors.filter((f) => !f.excludeFromRandom);
});
```

Derived stores are read-only (like readable stores) but their value is computed rather than set explicitly.

### Deriving from Multiple Stores

You can derive from multiple stores:

```typescript
const firstName = writable('Alice');
const lastName = writable('Smith');

const fullName = derived([firstName, lastName], ([$first, $last]) => `${$first} ${$last}`);

fullName.subscribe((value) => console.log(value));
// Output: "Alice Smith"

firstName.set('Bob');
// Output: "Bob Smith"
```

The first argument is an array of stores, and the callback receives an array of their values.

---

## The Subscription Pattern and Reactivity

Understanding subscriptions is key to understanding Svelte stores. Let's dig deeper into how they work.

### Manual Subscription

Here's what happens under the hood when you subscribe:

```typescript
const count = writable(0);

// Subscribe returns an unsubscribe function
const unsubscribe = count.subscribe((value) => {
  console.log('Current value:', value);
});
// Output: "Current value: 0" (called immediately with current value)

count.set(5);
// Output: "Current value: 5"

count.set(10);
// Output: "Current value: 10"

// Clean up when done
unsubscribe();

count.set(15);
// No output (we unsubscribed)
```

Key points:

1. Subscriptions are called **immediately** with the current value
2. They're called again whenever the value changes
3. You **must** unsubscribe to avoid memory leaks
4. The unsubscribe function is returned from `subscribe()`

### Auto-Subscription in Components

In Svelte components, the `$` prefix handles subscriptions automatically:

```svelte
<script>
  import { count } from './stores';
  import { onDestroy } from 'svelte';

  // This:
  let value = $count;

  // Is equivalent to this:
  let value;
  const unsubscribe = count.subscribe((v) => {
    value = v;
  });
  onDestroy(unsubscribe);
</script>

<p>{$count}</p>
```

Svelte's compiler transforms `$count` into a subscription with automatic cleanup. This is why the `$` syntax is so convenient.

### Multiple Subscribers

Stores support multiple simultaneous subscribers:

```typescript
const count = writable(0);

// First subscriber
count.subscribe((value) => {
  console.log('Subscriber 1:', value);
});

// Second subscriber
count.subscribe((value) => {
  console.log('Subscriber 2:', value);
});

count.set(5);
// Output:
// "Subscriber 1: 5"
// "Subscriber 2: 5"
```

All subscribers are notified whenever the value changes. They're called in the order they subscribed.

### Reactivity Chain

Stores create a reactive chain. When one store changes, all dependent stores update automatically:

```typescript
const a = writable(2);
const b = writable(3);
const c = derived([a, b], ([$a, $b]) => $a + $b);
const d = derived(c, ($c) => $c * 2);

d.subscribe((value) => console.log('d =', value));
// Output: "d = 10" (because (2 + 3) * 2 = 10)

a.set(5);
// Output: "d = 16" (because (5 + 3) * 2 = 16)
```

This is the foundation of Svelte's reactivity: changes propagate automatically through the dependency graph.

---

## Building Our Store: Design Decisions

Now let's look at how we built the state management for BroteinBuddy. We made several key decisions that shaped the implementation.

### Decision 1: Single Store vs Multiple Stores

**Option A: Multiple stores**

```typescript
export const boxes = writable<Box[]>([]);
export const flavors = writable<Flavor[]>([]);
export const settings = writable<Settings>({});
```

**Option B: Single unified store (what we chose)**

```typescript
export const appState = writable<AppState>({
  boxes: [],
  flavors: [],
  favoriteFlavorId: null,
  settings: {},
  version: 1,
});
```

**Why we chose option B:**

1. **Easier persistence**: One localStorage key instead of multiple
2. **Atomic updates**: When you add a box and update a flavor, it's one state change
3. **Simpler loading**: Load entire state in one operation
4. **Referential integrity**: Boxes reference flavors via `flavorId` - keeping them together makes sense
5. **No sync issues**: Can't get into states where stores are out of sync

**Trade-off we accepted:**

- Any change to any part of state notifies all subscribers
- For this app, that's fine (state is small, updates are infrequent)
- If we had performance issues, we'd add derived stores for specific slices

### Decision 2: Action Functions vs Methods

We could have attached methods to the store:

```typescript
// Option A: Methods on store object
export const appState = {
  subscribe,
  set,
  update,
  addBox(box: Box) { ... },
  removeBox(id: string) { ... }
};
```

But we chose separate action functions:

```typescript
// Option B: Separate action functions (what we chose)
export const appState = writable(...);
export function addBox(box: Box) { ... }
export function removeBox(id: string) { ... }
```

**Why separate functions?**

1. **Clearer API**: Store is just a store, actions are just functions
2. **Easier to test**: Can mock the store and test actions independently
3. **Follows Svelte idiom**: Most Svelte code uses this pattern
4. **Tree-shaking**: Unused actions can be eliminated by bundlers
5. **TypeScript-friendly**: Better type inference for function parameters

### Decision 3: Auto-Save on Every Change

We subscribe to the store and save to LocalStorage on every state change:

```typescript
function createAppStore(): Writable<AppState> {
  const initialState = loadState();
  const { subscribe, set, update } = writable<AppState>(initialState);

  // Auto-save to LocalStorage on every state change
  subscribe((state) => {
    try {
      saveState(state);
    } catch (error) {
      console.error('Failed to auto-save state:', error);
    }
  });

  return { subscribe, set, update };
}
```

**Why auto-save instead of manual save calls?**

1. **Users expect it**: No save button means everything should be saved
2. **Can't forget**: Every mutation automatically persists
3. **Simple**: No need to remember to call save()
4. **Fast enough**: Our data is small (< 100KB), synchronous saves are fine

**Alternative we considered but rejected:** Debouncing (waiting 500ms after last change before saving). We decided immediate saves are better for user experience - if they close the tab, everything is saved. We can add debouncing later if performance becomes an issue.

### Decision 4: No Referential Integrity Validation

Our actions don't validate that `flavorId` exists when adding boxes:

```typescript
export function addBox(box: Box): void {
  appState.update((state) => {
    // Check for duplicate ID
    if (state.boxes.some((b) => b.id === box.id)) {
      throw new Error(`Box with ID "${box.id}" already exists`);
    }

    // Does NOT check if box.flavorId exists in state.flavors

    return {
      ...state,
      boxes: [...state.boxes, box],
    };
  });
}
```

**Why not validate?**

- Allows flexible setup order (can add boxes before adding their flavors)
- UI layer enforces referential integrity (won't let users create invalid refs)
- Keeps the store layer simple and fast
- Can add strict mode validation later if needed

This is a pragmatic choice. For a personal app, the flexibility is valuable. For a multi-user app with complex workflows, you might choose strict validation.

---

## Auto-Save with Subscriptions

Let's dig deeper into our auto-save implementation because it's a pattern you'll use often.

### Basic Auto-Save Pattern

Here's the minimal version:

```typescript
const store = writable(initialValue);

// Subscribe and save on every change
store.subscribe((value) => {
  localStorage.setItem('key', JSON.stringify(value));
});
```

This works, but has problems:

1. Saves the initial value immediately (unnecessary)
2. No error handling
3. Blocks on save errors

### Our Improved Pattern

```typescript
function createAppStore(): Writable<AppState> {
  const initialState = loadState(); // Load from storage
  const { subscribe, set, update } = writable<AppState>(initialState);

  // Auto-save with error handling
  subscribe((state) => {
    try {
      saveState(state);
    } catch (error) {
      // Log but don't crash
      console.error('Failed to auto-save state:', error);
    }
  });

  return { subscribe, set, update };
}
```

**What this does:**

1. **Loads initial state**: Reads from LocalStorage first
2. **Creates store**: Wraps initial state in writable store
3. **Sets up auto-save**: Subscribes to save on every change
4. **Handles errors gracefully**: Logs save failures but doesn't crash app
5. **Returns store interface**: Only exposes subscribe, set, update

**Key insight:** The subscription runs immediately with the initial state, which saves it to LocalStorage. This is actually good - it ensures storage is in sync even if someone manually edited localStorage.

### Skipping Initial Save

If you want to avoid saving the initial value:

```typescript
function createAppStore(): Writable<AppState> {
  const initialState = loadState();
  const { subscribe, set, update } = writable<AppState>(initialState);

  let isInitialCall = true;
  subscribe((state) => {
    if (isInitialCall) {
      isInitialCall = false;
      return; // Skip first call
    }

    try {
      saveState(state);
    } catch (error) {
      console.error('Failed to auto-save state:', error);
    }
  });

  return { subscribe, set, update };
}
```

We didn't do this because:

- The initial save is harmless (idempotent)
- It ensures storage stays in sync
- Simpler code (less state to track)

### Handling Storage Quota Errors

Our `saveState` function (from the storage layer) throws when quota is exceeded:

```typescript
export function saveState(state: AppState): void {
  try {
    const json = JSON.stringify(state);
    localStorage.setItem(STORAGE_KEY, json);
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      throw new Error('Storage quota exceeded. Please clear some data.');
    }
    throw error;
  }
}
```

In our auto-save subscription, we catch this and log it:

```typescript
subscribe((state) => {
  try {
    saveState(state);
  } catch (error) {
    console.error('Failed to auto-save state:', error);
    // State change still succeeded in memory
    // UI could show a warning to the user
  }
});
```

**Why not rethrow?** Because the state change succeeded in memory. The app continues working, just without persistence for that change. The UI could display a warning: "Storage full, changes not saved" and let the user decide what to do (delete old data, export, etc.).

### Alternative: Debounced Auto-Save

For apps with frequent updates, debouncing can reduce localStorage writes:

```typescript
import { debounce } from './utils';

function createAppStore(): Writable<AppState> {
  const initialState = loadState();
  const { subscribe, set, update } = writable<AppState>(initialState);

  // Save at most once per 500ms
  const debouncedSave = debounce((state: AppState) => {
    try {
      saveState(state);
    } catch (error) {
      console.error('Failed to auto-save state:', error);
    }
  }, 500);

  subscribe(debouncedSave);

  return { subscribe, set, update };
}
```

**Debounce implementation:**

```typescript
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: ReturnType<typeof setTimeout> | null = null;

  return (...args: Parameters<T>) => {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}
```

**Trade-offs:**

- Pro: Better performance for rapid updates
- Pro: Reduces localStorage writes (extends SSD life)
- Con: Changes could be lost if page closes during debounce window
- Con: More complex (need to flush on page unload)

For BroteinBuddy, immediate saves are better. If you're building something like a drawing app or code editor with constant changes, debouncing makes sense.

---

## Action Pattern for Mutations

Actions are functions that modify the store in controlled ways. They're the public API for state changes.

### Why Actions Instead of Direct Updates?

You could let components call `update()` directly:

```svelte
<script>
  import { appState } from './stores';

  function addBox(box: Box) {
    appState.update((state) => ({
      ...state,
      boxes: [...state.boxes, box],
    }));
  }
</script>
```

This works, but:

1. Every component duplicates the update logic
2. Validation logic is scattered
3. Easy to make mistakes (forget to clone arrays, typos, etc.)
4. Hard to test (need to render components)

**With actions:**

```typescript
// stores.ts
export function addBox(box: Box): void {
  appState.update((state) => {
    // Validation in one place
    if (state.boxes.some((b) => b.id === box.id)) {
      throw new Error(`Box with ID "${box.id}" already exists`);
    }

    // Correct immutable update
    return {
      ...state,
      boxes: [...state.boxes, box],
    };
  });
}
```

```svelte
<script>
  import { addBox } from './stores';

  // Component just calls the action
  addBox(newBox);
</script>
```

Now:

- Validation is centralized
- Update logic is consistent
- Easy to test (unit test the function)
- Components stay simple

### Action Function Anatomy

Let's break down a complete action:

```typescript
/**
 * Adds a new box to the inventory.
 *
 * @param box - The box to add to inventory
 * @throws {Error} If a box with the same ID already exists
 */
export function addBox(box: Box): void {
  appState.update((state) => {
    // 1. Validate inputs
    if (state.boxes.some((b) => b.id === box.id)) {
      throw new Error(`Box with ID "${box.id}" already exists`);
    }

    // 2. Create new state immutably
    return {
      ...state,
      boxes: [...state.boxes, box],
    };
  });

  // 3. No return value (void)
  //    Changes are communicated via subscriptions
}
```

**Key parts:**

1. **Validation**: Check inputs and current state, throw on errors
2. **Immutable update**: Create new state object, never mutate
3. **No return**: Void return type, changes flow through subscriptions

### Action Error Handling

Actions throw on validation errors:

```typescript
export function updateBoxQuantity(boxId: string, newQuantity: number): void {
  // Validate input
  if (newQuantity < 0) {
    throw new Error(`Quantity must be non-negative, got ${newQuantity}`);
  }

  if (!Number.isInteger(newQuantity)) {
    throw new Error(`Quantity must be an integer, got ${newQuantity}`);
  }

  appState.update((state) => {
    // Validate box exists
    const boxIndex = state.boxes.findIndex((b) => b.id === boxId);
    if (boxIndex === -1) {
      throw new Error(`Box with ID "${boxId}" not found`);
    }

    // Update if validation passed
    const updatedBoxes = [...state.boxes];
    updatedBoxes[boxIndex] = {
      ...updatedBoxes[boxIndex],
      quantity: newQuantity,
    };

    return { ...state, boxes: updatedBoxes };
  });
}
```

**Why throw instead of returning error objects?**

Option A: Throw exceptions (what we do)

```typescript
try {
  updateBoxQuantity(boxId, -5);
} catch (error) {
  alert(error.message); // "Quantity must be non-negative"
}
```

Option B: Return result objects

```typescript
const result = updateBoxQuantity(boxId, -5);
if (!result.success) {
  alert(result.error);
}
```

We chose exceptions because:

- TypeScript forces you to handle them (or your app crashes)
- Shorter, cleaner code at call sites
- Standard JavaScript error handling pattern
- Easy to catch at UI boundary

### Partial Updates

For updating objects, accept partial updates:

```typescript
export function updateFlavor(flavorId: string, updates: Partial<Flavor>): void {
  appState.update((state) => {
    const flavorIndex = state.flavors.findIndex((f) => f.id === flavorId);
    if (flavorIndex === -1) {
      throw new Error(`Flavor with ID "${flavorId}" not found`);
    }

    const updatedFlavors = [...state.flavors];
    updatedFlavors[flavorIndex] = {
      ...updatedFlavors[flavorIndex],
      ...updates,
      // Ensure ID cannot be changed
      id: flavorId,
    };

    return { ...state, flavors: updatedFlavors };
  });
}
```

Usage:

```typescript
// Update just the name
updateFlavor('flavor_001', { name: 'Dark Chocolate' });

// Update just the flag
updateFlavor('flavor_001', { excludeFromRandom: true });

// Update both
updateFlavor('flavor_001', {
  name: 'Milk Chocolate',
  excludeFromRandom: false,
});
```

This is more convenient than requiring full objects and saves you from accidentally forgetting fields.

---

## Immutability and Spread Operators

Immutability is critical when working with stores. You must never mutate state directly. Here's why and how to maintain immutability.

### Why Immutability Matters

Svelte's reactivity depends on detecting when values change. If you mutate objects in place, Svelte can't detect the change:

```typescript
// Wrong - mutates state directly
appState.update((state) => {
  state.boxes.push(newBox); // Mutates array
  return state; // Same reference
});
// Subscribers DON'T fire because state reference didn't change
```

```typescript
// Right - creates new state
appState.update((state) => ({
  ...state,
  boxes: [...state.boxes, newBox], // New array
}));
// Subscribers fire because state reference changed
```

Svelte (and most reactive systems) use **reference equality** to detect changes. If you return the same object reference, Svelte assumes nothing changed.

### Immutable Update Patterns

**Adding to an array:**

```typescript
// Wrong
state.boxes.push(newBox);

// Right
boxes: [...state.boxes, newBox];
```

**Removing from an array:**

```typescript
// Wrong
const index = state.boxes.findIndex((b) => b.id === boxId);
state.boxes.splice(index, 1);

// Right
boxes: state.boxes.filter((b) => b.id !== boxId);
```

**Updating an array element:**

```typescript
// Wrong
const box = state.boxes.find((b) => b.id === boxId);
box.quantity = newQuantity;

// Right
boxes: state.boxes.map((box) => (box.id === boxId ? { ...box, quantity: newQuantity } : box));

// Alternative (more efficient for large arrays)
const updatedBoxes = [...state.boxes];
updatedBoxes[index] = { ...updatedBoxes[index], quantity: newQuantity };
return { ...state, boxes: updatedBoxes };
```

**Updating nested objects:**

```typescript
// Wrong
state.boxes[0].location.stack = 2;

// Right
boxes: state.boxes.map((box, i) =>
  i === 0 ? { ...box, location: { ...box.location, stack: 2 } } : box
);
```

**Updating object properties:**

```typescript
// Wrong
state.favoriteFlavorId = newId;

// Right
{ ...state, favoriteFlavorId: newId }
```

### Spread Operator Deep Dive

The spread operator (`...`) creates shallow copies:

```typescript
const original = { a: 1, b: { c: 2 } };
const copy = { ...original };

copy.a = 99; // Doesn't affect original
console.log(original.a); // 1

copy.b.c = 99; // DOES affect original
console.log(original.b.c); // 99 (nested object is shared!)
```

For nested structures, you need to spread at each level:

```typescript
// Shallow copy - NOT SAFE for nested objects
const copy = { ...original };

// Deep copy - safe for nested objects
const copy = {
  ...original,
  b: { ...original.b },
};
```

**In BroteinBuddy:** Our data structure is fairly shallow. Boxes and Flavors are one level deep, so single spread is enough:

```typescript
// Update box location (Location is nested, so spread both levels)
const updatedBox = {
  ...originalBox,
  location: { ...originalBox.location, stack: 2 },
};
```

### Common Immutability Mistakes

**Mistake 1: Forgetting to spread the parent**

```typescript
// Wrong - loses other state fields
appState.update((state) => ({
  boxes: [...state.boxes, newBox],
}));
// flavors, favoriteFlavorId, settings, version are gone!

// Right - preserves other fields
appState.update((state) => ({
  ...state,
  boxes: [...state.boxes, newBox],
}));
```

**Mistake 2: Mutating then spreading**

```typescript
// Wrong - mutates before spreading
const updatedBox = originalBox;
updatedBox.quantity = newQuantity; // Mutation!
const newBoxes = [...state.boxes];
// Too late, originalBox is already mutated

// Right - spread first, then override
const updatedBox = { ...originalBox, quantity: newQuantity };
```

**Mistake 3: Sorting/reversing in place**

```typescript
// Wrong - sort() mutates the array
boxes: state.boxes.sort((a, b) => a.quantity - b.quantity);

// Right - copy first, then sort
boxes: [...state.boxes].sort((a, b) => a.quantity - b.quantity);
```

### TypeScript's readonly Modifier

You can use `readonly` to catch mutations at compile time:

```typescript
interface AppState {
  readonly boxes: readonly Box[];
  readonly flavors: readonly Flavor[];
}

function buggyUpdate(state: AppState) {
  state.boxes.push(newBox); // TS Error: Property 'push' does not exist
  state.boxes = []; // TS Error: Cannot assign to 'boxes'
}
```

We didn't use `readonly` in BroteinBuddy because:

- Adds verbosity to type definitions
- Spread operators work fine without it
- Our actions are well-tested (mutations would fail tests)

But it's a great option for larger teams or critical codebases.

---

## Error Handling Strategies

Error handling in stores requires careful thought. You need to handle two types of errors differently.

### Validation Errors (Throw)

Validation errors indicate programming errors or invalid user input. These should throw:

```typescript
export function updateBoxQuantity(boxId: string, newQuantity: number): void {
  // Validate input
  if (newQuantity < 0) {
    throw new Error(`Quantity must be non-negative, got ${newQuantity}`);
  }

  appState.update((state) => {
    // Validate state
    const boxIndex = state.boxes.findIndex((b) => b.id === boxId);
    if (boxIndex === -1) {
      throw new Error(`Box with ID "${boxId}" not found`);
    }

    // Update
    // ...
  });
}
```

**Why throw?**

- Forces caller to handle the error
- Fails fast (catches bugs early)
- Standard JavaScript error pattern

**How to handle in UI:**

```svelte
<script>
  import { updateBoxQuantity } from './stores';

  function handleUpdate() {
    try {
      updateBoxQuantity(boxId, newQuantity);
      // Success - maybe show a toast
    } catch (error) {
      // Show error to user
      alert(error.message);
      // Or use a proper error notification system
    }
  }
</script>
```

### Storage Errors (Log)

Storage errors (quota exceeded, localStorage unavailable) shouldn't crash the app:

```typescript
subscribe((state) => {
  try {
    saveState(state);
  } catch (error) {
    // Log but don't throw
    console.error('Failed to auto-save state:', error);

    // Could dispatch a custom event for UI to catch
    window.dispatchEvent(
      new CustomEvent('storage-error', {
        detail: error,
      })
    );
  }
});
```

**Why log instead of throw?**

- State update succeeded in memory (app can continue)
- User can keep working even if saves fail
- UI can show a warning but doesn't need to block

**How to handle in UI:**

```svelte
<script>
  import { onMount } from 'svelte';

  let storageError = null;

  onMount(() => {
    window.addEventListener('storage-error', (event) => {
      storageError = event.detail.message;
    });
  });
</script>

{#if storageError}
  <div class="error-banner">
    Warning: Changes not saved. {storageError}
  </div>
{/if}
```

### Error Boundary Pattern

For production apps, consider an error boundary that catches all store errors:

```typescript
// error-store.ts
export const appError = writable<Error | null>(null);

export function withErrorHandling<T extends (...args: any[]) => any>(fn: T): T {
  return ((...args: Parameters<T>) => {
    try {
      return fn(...args);
    } catch (error) {
      appError.set(error);
      throw error; // Re-throw after capturing
    }
  }) as T;
}
```

```typescript
// stores.ts
export const addBox = withErrorHandling((box: Box): void => {
  appState.update(/* ... */);
});
```

```svelte
<!-- App.svelte -->
<script>
  import { appError } from './error-store';
</script>

{#if $appError}
  <ErrorDialog error={$appError} />
{/if}
```

This centralizes error handling so you don't need try-catch everywhere.

---

## Testing Stores with Vitest

Testing stores is straightforward because they're just functions. No DOM, no component mounting required.

### Basic Store Test

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { get } from 'svelte/store';
import { appState, addBox } from './stores';

describe('addBox', () => {
  beforeEach(() => {
    // Reset store before each test
    localStorage.clear();
    loadStateFromStorage(); // Resets to default state
  });

  it('should add a box to the state', () => {
    const box: Box = {
      id: 'box_001',
      flavorId: 'chocolate',
      quantity: 12,
      location: { stack: 0, height: 0 },
      isOpen: false,
    };

    addBox(box);

    const state = get(appState);
    expect(state.boxes).toHaveLength(1);
    expect(state.boxes[0]).toEqual(box);
  });

  it('should throw on duplicate ID', () => {
    const box: Box = { id: 'box_001' /* ... */ };

    addBox(box);

    expect(() => addBox(box)).toThrow('Box with ID "box_001" already exists');
  });
});
```

**Key testing utilities:**

- `get(store)`: Read current store value synchronously
- `beforeEach`: Reset state before each test
- `localStorage.clear()`: Clean storage between tests

### Testing Subscriptions

```typescript
it('should notify subscribers on change', () => {
  const values: number[] = [];

  const unsubscribe = appState.subscribe((state) => {
    values.push(state.boxes.length);
  });

  addBox(createTestBox());
  addBox(createTestBox());

  expect(values).toEqual([0, 1, 2]); // Initial, +1, +2

  unsubscribe();
});
```

### Testing Persistence

```typescript
it('should persist to localStorage', () => {
  const box: Box = { id: 'box_persist' /* ... */ };

  addBox(box);

  // Verify localStorage was updated
  const stored = localStorage.getItem('BROTEINBUDDY_APP_STATE');
  expect(stored).toBeTruthy();

  const parsed = JSON.parse(stored!);
  expect(parsed.boxes).toHaveLength(1);
  expect(parsed.boxes[0].id).toBe('box_persist');
});
```

### Testing Error Handling

```typescript
it('should continue working when save fails', () => {
  // Mock localStorage to throw
  vi.spyOn(Storage.prototype, 'setItem').mockImplementation(() => {
    throw new Error('Quota exceeded');
  });

  const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

  // Should not throw
  expect(() => {
    addBox(createTestBox());
  }).not.toThrow();

  // State should have updated (even though save failed)
  const state = get(appState);
  expect(state.boxes).toHaveLength(1);

  // Error should be logged
  expect(consoleSpy).toHaveBeenCalled();
});
```

### Testing Multiple Actions

```typescript
it('should handle full lifecycle', () => {
  const box: Box = { id: 'lifecycle', quantity: 12 /* ... */ };

  // Add
  addBox(box);
  let state = get(appState);
  expect(state.boxes).toHaveLength(1);

  // Update quantity
  updateBoxQuantity('lifecycle', 10);
  state = get(appState);
  expect(state.boxes[0].quantity).toBe(10);

  // Update location
  updateBoxLocation('lifecycle', { stack: 2, height: 1 });
  state = get(appState);
  expect(state.boxes[0].location).toEqual({ stack: 2, height: 1 });

  // Remove
  removeBox('lifecycle');
  state = get(appState);
  expect(state.boxes).toHaveLength(0);
});
```

### Test Helpers

Create reusable test helpers:

```typescript
// test-utils.ts
export function createTestBox(overrides?: Partial<Box>): Box {
  return {
    id: `box_${Date.now()}_${Math.random()}`,
    flavorId: 'flavor_test',
    quantity: 12,
    location: { stack: 0, height: 0 },
    isOpen: false,
    ...overrides,
  };
}

export function getCurrentState(): AppState {
  return get(appState);
}

export function resetStore(): void {
  localStorage.clear();
  loadStateFromStorage();
}
```

Use in tests:

```typescript
it('should add multiple boxes', () => {
  addBox(createTestBox({ id: 'box_1' }));
  addBox(createTestBox({ id: 'box_2' }));
  addBox(createTestBox({ id: 'box_3' }));

  const state = getCurrentState();
  expect(state.boxes).toHaveLength(3);
});
```

### Coverage Goals

For BroteinBuddy, we aimed for:

- **100% coverage on store actions** (critical path)
- **All happy paths** (successful operations)
- **All error paths** (validation failures, storage errors)
- **Integration scenarios** (multiple actions in sequence)

We achieved 51 tests with 100% coverage on `stores.ts`.

---

## Common Pitfalls and How to Avoid Them

Let's cover mistakes developers commonly make with Svelte stores.

### Pitfall 1: Forgetting to Unsubscribe

**Problem:**

```typescript
import { onMount } from 'svelte';
import { appState } from './stores';

onMount(() => {
  appState.subscribe((state) => {
    console.log('State changed:', state);
  });

  // Missing unsubscribe - memory leak!
});
```

Every time the component mounts, you create a new subscription. If the component mounts/unmounts multiple times, you accumulate subscriptions that never clean up.

**Solution 1: Use the $ prefix in components**

```svelte
<script>
  import { appState } from './stores';
</script>

<!-- Auto-subscribes and auto-unsubscribes --><p>{$appState.boxes.length} boxes</p>
```

**Solution 2: Store and call the unsubscribe function**

```typescript
import { onMount, onDestroy } from 'svelte';

let unsubscribe: () => void;

onMount(() => {
  unsubscribe = appState.subscribe((state) => {
    console.log('State changed:', state);
  });
});

onDestroy(() => {
  if (unsubscribe) unsubscribe();
});
```

**Solution 3: Use onDestroy's auto-call**

```typescript
import { onMount, onDestroy } from 'svelte';

onMount(() => {
  const unsubscribe = appState.subscribe((state) => {
    console.log('State changed:', state);
  });

  // onDestroy accepts a function to call
  onDestroy(unsubscribe);
});
```

### Pitfall 2: Mutating State Directly

**Problem:**

```typescript
export function updateBoxQuantity(boxId: string, newQuantity: number): void {
  appState.update((state) => {
    const box = state.boxes.find((b) => b.id === boxId);
    if (box) {
      box.quantity = newQuantity; // Mutation!
    }
    return state; // Same reference
  });
}
```

This doesn't trigger subscriptions because the state reference didn't change.

**Solution:**

```typescript
export function updateBoxQuantity(boxId: string, newQuantity: number): void {
  appState.update((state) => {
    const boxIndex = state.boxes.findIndex((b) => b.id === boxId);
    if (boxIndex === -1) {
      throw new Error(`Box not found: ${boxId}`);
    }

    // Create new array with updated box
    const updatedBoxes = [...state.boxes];
    updatedBoxes[boxIndex] = {
      ...updatedBoxes[boxIndex],
      quantity: newQuantity,
    };

    // Return new state object
    return { ...state, boxes: updatedBoxes };
  });
}
```

### Pitfall 3: Using set() Instead of update()

**Problem:**

```typescript
export function addBox(box: Box): void {
  const current = get(appState);
  appState.set({
    ...current,
    boxes: [...current.boxes, box],
  });
}
```

This has a race condition. Between `get()` and `set()`, another action might have modified the store. Your `set()` overwrites those changes.

**Solution: Use update() for state-dependent changes**

```typescript
export function addBox(box: Box): void {
  appState.update((state) => ({
    ...state,
    boxes: [...state.boxes, box],
  }));
}
```

The `update()` callback receives the current state at the moment of execution, avoiding race conditions.

**When to use set() vs update():**

- `set()`: Setting to a completely new value (not based on current)
- `update()`: Modifying based on current value

### Pitfall 4: Async in update() Callback

**Problem:**

```typescript
export function addBoxAsync(box: Box): void {
  appState.update(async (state) => {
    // Wrong!
    await validateBox(box); // Async operation
    return { ...state, boxes: [...state.boxes, box] };
  });
}
```

The `update()` callback should be synchronous. Async callbacks break reactivity.

**Solution: Do async work outside update()**

```typescript
export async function addBoxAsync(box: Box): Promise<void> {
  // Async work first
  await validateBox(box);

  // Synchronous update after
  appState.update((state) => ({
    ...state,
    boxes: [...state.boxes, box],
  }));
}
```

### Pitfall 5: Circular Store Dependencies

**Problem:**

```typescript
// store-a.ts
import { b } from './store-b';
export const a = derived(b, ($b) => $b * 2);

// store-b.ts
import { a } from './store-a';
export const b = derived(a, ($a) => $a + 1);
```

This creates a circular dependency and will crash at module load time.

**Solution: Rethink your data flow**

Usually, circular dependencies indicate a design problem. One store should be the source of truth:

```typescript
// stores.ts
export const base = writable(5);
export const doubled = derived(base, ($base) => $base * 2);
export const plusOne = derived(doubled, ($doubled) => $doubled + 1);
```

### Pitfall 6: Over-Subscribing

**Problem:**

```svelte
<script>
  import { appState } from './stores';

  // Every box re-renders when ANY part of state changes
</script>

{#each $appState.boxes as box}
  <BoxCard {box} />
{/each}
```

If `favoriteFlavorId` changes, all boxes re-render even though they don't care about that field.

**Solution 1: Derived stores for specific slices**

```typescript
export const boxes = derived(appState, ($state) => $state.boxes);
```

```svelte
{#each $boxes as box}
  <BoxCard {box} />
{/each}
```

Now components only re-render when boxes change.

**Solution 2: Component-level optimization**

```svelte
<!-- BoxList.svelte -->
<script>
  import { appState } from './stores';
  import BoxCard from './BoxCard.svelte';

  // Extract just boxes
  $: boxes = $appState.boxes;
</script>

{#each boxes as box (box.id)}
  <BoxCard {box} />
{/each}
```

The `(box.id)` key helps Svelte reuse DOM nodes efficiently.

For BroteinBuddy's scale, over-subscription isn't a problem. But for large apps with hundreds of components, derived stores for specific slices improve performance significantly.

---

## Performance Considerations

Svelte stores are fast, but here are things to consider for larger apps.

### Store Size and Update Frequency

**Our approach (single large store):**

```typescript
export const appState = writable({
  boxes: [...],      // Could be 100+ items
  flavors: [...],    // 10-20 items
  favoriteFlavorId,  // Simple value
  settings: {...}    // Small object
});
```

**Performance characteristics:**

- Every update notifies ALL subscribers
- Subscribers run even if their relevant data didn't change
- For small state (< 1MB), this is fine
- For large state or frequent updates, consider splitting

**When to split stores:**

```typescript
// If you have 10,000 boxes and update them constantly:
export const boxes = writable<Box[]>([]);
export const flavors = writable<Flavor[]>([]);
export const settings = writable<Settings>({});
```

Now updating a box doesn't notify flavor subscribers.

### Derived Store Performance

Derived stores recompute on every dependency change:

```typescript
export const totalQuantity = derived(appState, ($state) => {
  // Runs on EVERY state change, even non-box changes
  return $state.boxes.reduce((sum, box) => sum + box.quantity, 0);
});
```

**Optimization: Derive from specific slices**

```typescript
const boxes = derived(appState, ($state) => $state.boxes);

export const totalQuantity = derived(boxes, ($boxes) => {
  // Only runs when boxes change
  return $boxes.reduce((sum, box) => sum + box.quantity, 0);
});
```

### Auto-Save Performance

Our immediate auto-save is fine for small data:

```typescript
subscribe((state) => {
  saveState(state); // Synchronous, blocks main thread
});
```

**Measured performance:**

- Our AppState: ~10KB JSON
- Serialization: < 1ms
- localStorage.setItem: < 2ms
- Total: ~3ms per save

**When to add debouncing:**

- Data > 100KB
- Updates multiple times per second
- Users report UI lag

**Debounced version:**

```typescript
const debouncedSave = debounce((state: AppState) => {
  saveState(state);
}, 500);

subscribe(debouncedSave);
```

### Subscription Performance

Each subscriber adds overhead:

```typescript
// 100 components all subscribing
appState.subscribe(/* ... */); // 100 subscribers
```

For 100 subscribers with small state, this is fine (microseconds per update). For 1000+ subscribers or huge state objects, consider:

1. **Derived stores** to reduce subscriber count
2. **Context API** for deeply nested component trees
3. **Event bus** for cross-cutting concerns

### LocalStorage Performance

localStorage is synchronous and can block the main thread:

```typescript
// Blocks for ~2ms
localStorage.setItem('key', largeString);
```

**Alternatives for large data:**

1. **IndexedDB**: Async, can store GBs, but more complex
2. **Debouncing**: Reduce write frequency
3. **Web Workers**: Offload serialization (requires message passing overhead)

For BroteinBuddy, localStorage is perfect. For apps with > 10MB of data, consider IndexedDB.

---

## When to Use Context vs Stores

Svelte offers two ways to share data: stores and context. When should you use each?

### Context API Quick Recap

Context lets parent components provide values to descendants:

```svelte
<!-- Parent.svelte -->
<script>
  import { setContext } from 'svelte';

  const data = { user: 'Alice' };
  setContext('app-data', data);
</script>

<Child />
```

```svelte
<!-- Child.svelte -->
<script>
  import { getContext } from 'svelte';

  const data = getContext('app-data');
</script>

<p>User: {data.user}</p>
```

### Stores vs Context: Decision Matrix

| Factor                   | Stores                     | Context                         | Winner  |
| ------------------------ | -------------------------- | ------------------------------- | ------- |
| Scope                    | Global (import anywhere)   | Component tree only             | Stores  |
| Reactivity               | Built-in (writable stores) | Manual (need stores in context) | Stores  |
| Testing                  | Easy (import and test)     | Harder (need component tree)    | Stores  |
| Type safety              | Excellent (export typed)   | Manual (need type assertions)   | Stores  |
| Dependency injection     | Implicit (import)          | Explicit (via context)          | Context |
| Isolated component trees | Possible but awkward       | Natural fit                     | Context |
| Setup complexity         | None (just import)         | Need provider component         | Stores  |

### Use Stores When...

**1. App-wide state**

State that many unrelated components need:

```typescript
// stores.ts
export const currentUser = writable<User | null>(null);
export const appTheme = writable<'light' | 'dark'>('light');
```

Any component can import and use these stores.

**2. Persistent state**

State that needs to persist to localStorage:

```typescript
export const appState = writable({
  /* ... */
});

// Auto-save setup
subscribe((state) => {
  localStorage.setItem('state', JSON.stringify(state));
});
```

**3. Cross-component communication**

When components need to communicate without a parent-child relationship:

```typescript
export const selectedBoxId = writable<string | null>(null);

// BoxList selects
function selectBox(id: string) {
  selectedBoxId.set(id);
}

// BoxDetails displays (in different part of tree)
$: box = $appState.boxes.find((b) => b.id === $selectedBoxId);
```

**4. Easy testing**

Stores can be tested without rendering components:

```typescript
it('should add box', () => {
  addBox(testBox);
  expect(get(appState).boxes).toHaveLength(1);
});
```

### Use Context When...

**1. Component-scoped data**

Data that only matters within a component tree:

```svelte
<!-- Form.svelte -->
<script>
  import { setContext } from 'svelte';

  const formData = writable({ name: '', email: '' });
  setContext('form', { formData });
</script>

<FormFields />
<FormSummary />
```

```svelte
<!-- FormFields.svelte -->
<script>
  import { getContext } from 'svelte';

  const { formData } = getContext('form');
</script>

<input bind:value={$formData.name} />
```

**2. Dependency injection**

When you want explicit control over what data components receive:

```svelte
<!-- App.svelte -->
<script>
  import { setContext } from 'svelte';
  import { createAuthService } from './services';

  const auth = createAuthService();
  setContext('auth', auth);
</script>

<Router />
```

Components use `getContext('auth')` instead of importing a global service.

**3. Multiple instances**

When you render the same component tree multiple times with different data:

```svelte
{#each modals as modal}
  <ModalProvider data={modal}>
    <ModalContent />
  </ModalProvider>
{/each}
```

Each modal has its own isolated context.

**4. Library components**

When building reusable component libraries where users might have multiple instances:

```svelte
<!-- Tabs.svelte (library component) -->
<script>
  setContext('tabs', { activeTab });
</script>

<TabList />
<TabPanels />
```

Users can have multiple `<Tabs>` components without conflicts.

### Hybrid Approach

Often, the best approach is combining both:

```typescript
// Global state in stores
export const appState = writable<AppState>({
  /* ... */
});

// Component-scoped utilities in context
setContext('inventory', {
  appState, // Provide the store via context
  addBox,
  removeBox,
  // ... other actions
});
```

This gives you:

- Global state via stores (easy testing, persistence)
- Explicit dependencies via context (clear data flow)

### BroteinBuddy's Choice

We chose stores for everything because:

1. Simple app structure (not many nested trees)
2. Most state is truly global
3. Easier testing (import and test, no component rendering)
4. Direct imports are simpler than context boilerplate

For a larger app with complex component hierarchies, we might use context for isolated features (like a modal system or form builder) while keeping app state in stores.

---

## Future Enhancements

Our current store implementation is solid, but here are enhancements we might add later.

### 1. Derived Stores for Computed Values

Instead of computing in components:

```svelte
<script>
  import { appState } from './stores';

  $: totalQuantity = $appState.boxes.reduce((sum, box) => sum + box.quantity, 0);
</script>
```

Create derived stores:

```typescript
// stores.ts
export const totalQuantity = derived(appState, ($state) => {
  return $state.boxes.reduce((sum, box) => sum + box.quantity, 0);
});

export const quantityByFlavor = derived(appState, ($state) => {
  const map = new Map<string, number>();
  for (const box of $state.boxes) {
    const current = map.get(box.flavorId) || 0;
    map.set(box.flavorId, current + box.quantity);
  }
  return map;
});

export const openBoxes = derived(appState, ($state) => $state.boxes.filter((box) => box.isOpen));
```

Components just import and use:

```svelte
<script>
  import { totalQuantity, openBoxes } from './stores';
</script>

<p>Total: {$totalQuantity}</p><p>Open boxes: {$openBoxes.length}</p>
```

Benefits:

- Computation happens once per state change, not once per component
- Consistent values across all components
- Easier to test (derived stores are functions)

### 2. Undo/Redo

Track state history to support undo/redo:

```typescript
interface HistoryEntry {
  state: AppState;
  timestamp: number;
  action: string;
}

const history = writable<HistoryEntry[]>([]);
const currentIndex = writable(0);

export function undo(): void {
  currentIndex.update((i) => {
    const newIndex = Math.max(0, i - 1);
    const entry = get(history)[newIndex];
    if (entry) {
      appState.set(entry.state);
    }
    return newIndex;
  });
}

export function redo(): void {
  currentIndex.update((i) => {
    const historyList = get(history);
    const newIndex = Math.min(historyList.length - 1, i + 1);
    const entry = historyList[newIndex];
    if (entry) {
      appState.set(entry.state);
    }
    return newIndex;
  });
}
```

Wrap actions to record history:

```typescript
export function addBox(box: Box): void {
  // Record current state before change
  recordHistory('Add box');

  appState.update((state) => ({
    ...state,
    boxes: [...state.boxes, box],
  }));
}
```

Challenges:

- Large state history can use lots of memory
- Need to limit history depth (e.g., last 20 changes)
- Undo/redo interacts poorly with auto-save (each undo saves to localStorage)

### 3. Optimistic Updates

For network operations (if we add a backend later):

```typescript
export async function syncBox(box: Box): Promise<void> {
  // Optimistically add to state
  const tempId = `temp_${Date.now()}`;
  const optimisticBox = { ...box, id: tempId };
  addBox(optimisticBox);

  try {
    // Save to server
    const savedBox = await api.createBox(box);

    // Replace temp box with real box
    appState.update((state) => ({
      ...state,
      boxes: state.boxes.map((b) => (b.id === tempId ? savedBox : b)),
    }));
  } catch (error) {
    // Rollback on failure
    removeBox(tempId);
    throw error;
  }
}
```

This makes the UI feel instant even with network latency.

### 4. Multi-Tab Sync

Listen for localStorage changes from other tabs:

```typescript
window.addEventListener('storage', (event) => {
  if (event.key === 'BROTEINBUDDY_APP_STATE' && event.newValue) {
    // Reload state when another tab makes changes
    const newState = JSON.parse(event.newValue);
    appState.set(newState);
  }
});
```

Challenges:

- Merge conflicts (two tabs edit simultaneously)
- Notification spam (every change triggers storage event)
- Last-write-wins semantics might surprise users

### 5. Middleware Pattern

Add hooks for logging, analytics, debugging:

```typescript
type Middleware = (actionName: string, args: any[], next: () => void) => void;

const middlewares: Middleware[] = [];

export function addMiddleware(middleware: Middleware): void {
  middlewares.push(middleware);
}

function withMiddleware(actionName: string, fn: Function) {
  return (...args: any[]) => {
    let index = 0;

    function next() {
      if (index < middlewares.length) {
        middlewares[index++](actionName, args, next);
      } else {
        fn(...args);
      }
    }

    next();
  };
}

// Wrap actions
export const addBox = withMiddleware('addBox', (box: Box) => {
  appState.update(/* ... */);
});
```

Usage:

```typescript
// Logging middleware
addMiddleware((action, args, next) => {
  console.log(`[Action] ${action}`, args);
  const start = performance.now();
  next();
  console.log(`[Action] ${action} took ${performance.now() - start}ms`);
});

// Analytics middleware
addMiddleware((action, args, next) => {
  analytics.track(action, { args });
  next();
});
```

### 6. Debounced Auto-Save

Reduce localStorage writes for rapid updates:

```typescript
const debouncedSave = debounce((state: AppState) => {
  saveState(state);
}, 500);

subscribe(debouncedSave);
```

Need to flush on page unload:

```typescript
window.addEventListener('beforeunload', () => {
  // Flush pending save
  const state = get(appState);
  saveState(state);
});
```

---

## References and Further Reading

### Official Svelte Documentation

- [Svelte Stores](https://svelte.dev/docs/svelte-store) - Official API documentation
- [Svelte Tutorial: Stores](https://learn.svelte.dev/tutorial/writable-stores) - Interactive tutorial
- [Svelte Store Contract](https://svelte.dev/docs/svelte-components#script-4-prefix-stores-with-$-to-access-their-values-store-contract) - How stores work under the hood

### Related BroteinBuddy Documentation

- [ADR-004: State Management Approach](../adr/004-state-management-approach.md) - Design decisions for this implementation
- [ADR-002: Data Model Design](../adr/002-data-model-design.md) - TypeScript interfaces
- [ADR-003: LocalStorage Strategy](../adr/003-localstorage-strategy.md) - Storage layer design
- [Teaching Doc 1.1: Type-Driven Design](1.1-type-driven-design.md) - TypeScript type guards
- [Teaching Doc 1.2: Web Storage Best Practices](1.2-web-storage-best-practices.md) - LocalStorage patterns

### Advanced Topics

- [Runes (Svelte 5)](https://svelte.dev/docs/svelte/what-are-runes) - New reactivity system in Svelte 5
- [Custom Stores](https://svelte.dev/examples/custom-stores) - Building stores with custom logic
- [Store Bindings](https://svelte.dev/examples/store-bindings) - Two-way binding with stores

### Patterns and Best Practices

- [State Management Patterns](https://www.joshwcomeau.com/react/state-machines/) - Finite state machines (applicable to Svelte)
- [Immutability in JavaScript](https://www.sitepoint.com/immutability-javascript/) - Why and how
- [Testing Svelte Stores](https://timdeschryver.dev/blog/how-to-test-svelte-stores) - Testing strategies

### Alternative Approaches

- [Svelte Store Addons](https://github.com/svelte-plugins/svelte-store-addons) - Useful store utilities
- [nanostores](https://github.com/nanostores/nanostores) - Framework-agnostic stores
- [XState](https://xstate.js.org/) - State machines (when store logic gets complex)

---

## Conclusion

Svelte stores provide a simple, powerful way to manage application state. Key takeaways:

1. **Stores are observable values** - They notify subscribers when they change
2. **Three types** - Writable (read/write), readable (read-only external), derived (computed)
3. **Subscriptions enable reactivity** - The `$` prefix auto-subscribes in components
4. **Auto-save pattern** - Subscribe to store and persist to LocalStorage
5. **Actions centralize mutations** - Functions that update the store consistently
6. **Immutability is critical** - Always create new objects/arrays, never mutate
7. **Error handling varies** - Throw for validation errors, log for storage errors
8. **Testing is straightforward** - Import, call actions, verify with `get()`
9. **Avoid pitfalls** - Unsubscribe properly, don't mutate, use update() not set()
10. **Stores vs context** - Stores for global state, context for component-scoped data

Our BroteinBuddy implementation demonstrates these principles in a real-world app. We chose simplicity (single store, immediate saves, no debouncing) because it fits our requirements. For larger apps, you'd add derived stores, debouncing, and more sophisticated error handling.

The beauty of Svelte stores is that you can start simple and add complexity only when needed. Start with a writable store, add derived stores when you need computed values, add middleware when you need logging - all without rewriting your core state management.

Happy storing!
