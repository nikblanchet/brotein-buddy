# Code Quality Automation: ESLint, Prettier, and Git Hooks

## What We Built

Code quality automation is the foundation of maintainable software. We implemented a comprehensive system that catches bugs before they're committed, enforces consistent code style across the entire project, and integrates seamlessly with both the command line and VS Code editor.

The system consists of four interconnected tools:

1. **ESLint** - Static analysis to catch bugs, enforce best practices, and detect code smells in TypeScript and Svelte files
2. **Prettier** - Opinionated code formatter that ensures consistent style without manual intervention
3. **Husky** - Git hooks manager that runs quality checks before every commit
4. **lint-staged** - Performance optimizer that only checks files you're actually committing

Together, they create an invisible quality safety net. You write code, save files, and everything gets formatted automatically. When you commit, only your staged files get checked, and any fixable issues are auto-corrected. If something can't be fixed automatically, the commit fails with a clear error message. You never have to think about code style debates or remember to run linting manually.

## Why This Approach

### The Problem We Solved

Without automated code quality tools, projects suffer from several issues:

- **Inconsistent style** - Every developer has different formatting preferences (tabs vs spaces, single vs double quotes, etc.)
- **Bugs slip through** - TypeScript catches type errors, but many logic errors and bad practices go unnoticed
- **Code review friction** - Reviews get bogged down in style debates instead of focusing on logic
- **Context switching** - Developers have to remember to run linters manually before committing
- **Slow feedback** - Issues discovered after commit require additional commits to fix

On a solo project, you might think consistency doesn't matter. But future you is a different developer. Six months from now, you'll have different habits, preferences, and muscle memory. Automated quality tools ensure your codebase stays consistent over time.

For projects with multiple developers (or multiple AI coding assistants!), automation is essential. It eliminates bikeshedding, enforces team standards, and catches issues immediately.

### Options We Considered

#### 1. Manual linting only (no automation)

**Approach**: Add ESLint and Prettier, but rely on developers to run them manually

- **Pros**:
  - Simple setup
  - No git hooks to maintain
  - Developers have full control
- **Cons**:
  - Humans forget to run tools
  - Inconsistent application
  - Style issues slip into the repository
  - CI failures after code is already committed
- **Why we didn't choose it**: Manual processes don't scale, even on solo projects. You'll forget. Future you will definitely forget.

#### 2. CI-only enforcement

**Approach**: Only run linting in CI/CD, fail builds if issues are found

- **Pros**:
  - No local tooling required
  - Centralized enforcement
  - Can't bypass checks
- **Cons**:
  - Very slow feedback loop (only after push)
  - Wastes CI resources on style issues
  - Frustrating developer experience
  - Multiple commits to fix simple style issues
- **Why we didn't choose it**: This is like getting spell-check feedback a week after writing an essay. Feedback needs to be immediate.

#### 3. Pre-commit hooks with git hooks (no Husky) <- **We chose this**

**Approach**: Use Husky + lint-staged to run ESLint and Prettier on staged files before every commit

- **Pros**:
  - Immediate feedback (before commit)
  - Only checks changed files (fast)
  - Auto-fixes most issues
  - Impossible to commit bad code
  - Works locally and in CI
  - Husky is the industry standard
  - Zero configuration for new developers (auto-installed via npm install)
- **Cons**:
  - Slightly slower commits
  - Requires Node.js environment
  - Can be bypassed with --no-verify (though this is intentional for emergencies)
- **Why we chose it**: Perfect balance of automation and developer experience. Catches issues at the best possible time - before they enter the repository.

#### 4. Editor-only formatting (format-on-save)

**Approach**: Configure editor to format on save, skip pre-commit checks

- **Pros**:
  - Seamless developer experience
  - Instant feedback
  - No commit delays
- **Cons**:
  - Only works in configured editors
  - Doesn't enforce linting rules
  - Easy to bypass (save, then modify without saving)
  - No protection for command-line git workflows
- **Why we didn't choose it**: This is a good supplement but not a replacement. We included editor integration as a bonus, but pre-commit hooks are the real enforcement.

## How It Works

### ESLint: The Code Quality Guardian

ESLint analyzes your JavaScript, TypeScript, and Svelte code to find problems. It's like having a senior developer constantly reviewing your code for common mistakes.

**What ESLint catches:**

- Unused variables and imports
- Missing type annotations
- Logic errors (like conditions that are always true)
- Accessibility issues in Svelte components
- Best practice violations
- Potential bugs

**Example problems ESLint finds:**

```typescript
// ESLint error: 'userName' is assigned but never used
const userName = 'Alice';

// ESLint warning: Unnecessary use of boolean literals in conditional expression
const result = isValid ? true : false;
// Should be: const result = isValid;

// ESLint error: Missing return type on function
function calculateTotal(items) {
  // Should be: function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

#### ESLint v9 Flat Config: Why We Migrated

ESLint recently introduced a new "flat config" format (`eslint.config.js`) to replace the old `.eslintrc.json` format. This was a breaking change, but for good reasons.

**Old format (.eslintrc.json):**

```json
{
  "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  "plugins": ["@typescript-eslint", "svelte"],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest"
  },
  "rules": {
    "@typescript-eslint/no-unused-vars": "warn"
  },
  "overrides": [
    {
      "files": ["*.svelte"],
      "parser": "svelte-eslint-parser"
    }
  ]
}
```

**New format (eslint.config.js):**

```javascript
import js from '@eslint/js';
import ts from '@typescript-eslint/eslint-plugin';
import tsParser from '@typescript-eslint/parser';

export default [
  js.configs.recommended,
  {
    files: ['**/*.js', '**/*.ts'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
      },
    },
    plugins: {
      '@typescript-eslint': ts,
    },
    rules: {
      ...ts.configs.recommended.rules,
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
];
```

**Why flat config is better:**

1. **It's JavaScript, not JSON**: You can use imports, variables, functions, and comments. This makes complex configurations much more maintainable.

2. **Explicit imports**: Instead of magic strings like `"plugin:@typescript-eslint/recommended"`, you import the actual plugin. This makes it clear what dependencies you need and provides better IDE autocomplete.

3. **Simpler mental model**: The old system had extends, overrides, and env all interacting in complex ways. Flat config is just an array of configuration objects that are applied in order.

4. **Better performance**: ESLint can load configurations more efficiently because it doesn't need to resolve string-based extends chains.

5. **Future-proof**: This is the direction ESLint is heading. Starting with v9, flat config is the default.

**Our configuration structure:**

```javascript
export default [
  // 1. Base JavaScript rules
  js.configs.recommended,

  // 2. TypeScript and JavaScript files
  {
    files: ['**/*.js', '**/*.ts'],
    languageOptions: { parser: tsParser },
    plugins: { '@typescript-eslint': ts },
    rules: {
      /* TypeScript rules */
    },
  },

  // 3. Svelte files (need special parser)
  {
    files: ['**/*.svelte'],
    languageOptions: {
      parser: svelteParser,
      parserOptions: { parser: tsParser }, // For <script> blocks
    },
    plugins: { svelte },
    rules: {
      /* Svelte rules */
    },
  },

  // 4. Prettier integration (disables conflicting rules)
  prettier,

  // 5. Ignore patterns
  {
    ignores: ['dist', 'node_modules', '.claude', '.planning'],
  },
];
```

Each configuration object applies to specific files and adds rules, parsers, or plugins. Later configs override earlier ones. It's explicit and predictable.

### Prettier: The Style Enforcer

Prettier is an opinionated code formatter. It doesn't care about code quality - that's ESLint's job. Prettier only cares about style: indentation, quotes, semicolons, line length, trailing commas, etc.

**Why opinionated?**

Prettier intentionally provides very few configuration options. This is a feature, not a bug. Style debates waste time. Prettier ends the debate by making most decisions for you.

Our configuration (`.prettierrc`):

```json
{
  "semi": true, // Use semicolons
  "singleQuote": true, // Single quotes instead of double
  "tabWidth": 2, // 2 spaces per indent
  "useTabs": false, // Spaces, not tabs
  "trailingComma": "es5", // Trailing commas where valid in ES5
  "printWidth": 100, // Wrap lines at 100 characters
  "plugins": ["prettier-plugin-svelte"]
}
```

These are the only decisions we made. Everything else is Prettier's defaults.

**Example transformation:**

```javascript
// Before Prettier
const user = {
  name: 'Alice',
  age: 30,
  email: 'alice@example.com',
  city: 'San Francisco',
  state: 'CA',
};

// After Prettier
const user = {
  name: 'Alice',
  age: 30,
  email: 'alice@example.com',
  city: 'San Francisco',
  state: 'CA',
};
```

Prettier formatted the object for readability and changed double quotes to single quotes. It's consistent, predictable, and automatic.

### ESLint + Prettier Integration

ESLint and Prettier have overlapping responsibilities. ESLint can check formatting rules (like quote style), but Prettier is better at it. If both try to format code, they fight each other.

**The solution: eslint-config-prettier**

This package disables all ESLint rules that conflict with Prettier. We include it as the last item in our ESLint config:

```javascript
export default [
  js.configs.recommended,
  {
    /* TypeScript config */
  },
  {
    /* Svelte config */
  },
  prettier, // <- Disables conflicting rules
];
```

Now ESLint handles code quality, Prettier handles formatting, and they don't step on each other's toes.

**Workflow:**

1. You write code (possibly with style issues and linting errors)
2. Prettier formats it (fixes style)
3. ESLint checks it (finds logic issues)
4. ESLint auto-fixes what it can
5. You fix what ESLint can't

### Husky: The Git Hook Manager

Git hooks are scripts that run automatically at certain points in the git workflow. The most useful hook is `pre-commit`, which runs before a commit is created.

**Traditional git hooks:**

```bash
# .git/hooks/pre-commit
#!/bin/sh
npm run lint
npm run test
```

Problems:

- Hooks live in `.git/hooks/`, which isn't committed to the repository
- Each developer must set up hooks manually
- Easy to forget or misconfigure

**Husky solves this:**

Husky stores hooks in the repository (`.husky/`) and automatically installs them when you run `npm install`. Every developer gets the same hooks with zero configuration.

Our pre-commit hook (`.husky/pre-commit`):

```bash
npx lint-staged
```

That's it. One line. All the magic happens in `lint-staged`.

### lint-staged: The Performance Optimizer

Running ESLint and Prettier on the entire codebase before every commit would be slow. Most commits only change a few files.

**lint-staged runs tools only on staged files.**

Configuration in `package.json`:

```json
{
  "lint-staged": {
    "*.{js,ts,svelte}": ["eslint --fix", "prettier --write"],
    "*.{json,md,css,html}": ["prettier --write"]
  }
}
```

**How it works:**

1. You stage files: `git add src/App.svelte`
2. You commit: `git commit -m "Add feature"`
3. Husky intercepts the commit and runs `lint-staged`
4. lint-staged finds staged files matching `*.{js,ts,svelte}`
5. It runs `eslint --fix` on those files
6. It runs `prettier --write` on those files
7. It stages the changes (so fixes are included in the commit)
8. If all commands succeed, the commit proceeds
9. If any command fails, the commit is aborted

**Performance:**

- Checking 3 files: ~0.5 seconds
- Checking entire codebase: ~10 seconds

lint-staged makes commits fast, which is critical for a good developer experience.

### VS Code Integration: The Optional Layer

We included VS Code settings in the repository (`.vscode/settings.json`) to make the development experience even smoother.

**What it does:**

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  }
}
```

When you save a file in VS Code:

1. Prettier formats it
2. ESLint auto-fixes any issues it can
3. Changes are applied immediately

**This is optional.** The pre-commit hook is the real enforcement. Editor integration just makes the experience nicer by giving you instant feedback.

**Why commit editor settings?**

This is a bit controversial. Some projects avoid committing editor settings to respect developer choice. We included them because:

1. **Consistency**: Everyone gets the same experience
2. **Zero configuration**: Works immediately after cloning
3. **Better for onboarding**: New developers don't need to configure anything
4. **Safe**: These settings don't override global preferences, only project-specific behavior

If a developer uses a different editor (Vim, Emacs, etc.), they can configure it however they want. The pre-commit hook still ensures code quality.

We also included recommended extensions (`.vscode/extensions.json`):

```json
{
  "recommendations": ["svelte.svelte-vscode", "dbaeumer.vscode-eslint", "esbenp.prettier-vscode"]
}
```

VS Code prompts you to install these when you open the project.

## Design Trade-offs

### What We Optimized For

1. **Developer experience**: Tools should be invisible until they catch a problem
2. **Speed**: Checks should be fast enough that developers don't notice
3. **Automation**: No manual steps, no decisions to remember
4. **Consistency**: Same results for everyone, in every environment
5. **Clear feedback**: When something fails, the error message should be obvious

### What We Sacrificed

1. **Perfect speed**: Commits are slightly slower (0.5-2 seconds) due to pre-commit hooks
2. **Flexibility**: Developers can't commit code that violates rules (this is intentional)
3. **Configuration complexity**: ESLint v9 flat config is more verbose than the old format

These are acceptable trade-offs. Slightly slower commits are worth the guarantee of consistent code quality. Limited flexibility prevents bad code from entering the repository. Complex configuration is offset by better maintainability.

## Real-World Compromises

### ESLint Rule Strictness

We configured ESLint to use `recommended` rules, not `strict` or `all`. Why not maximum strictness?

**Reason**: BroteinBuddy is a small, solo project (with AI assistance). Maximum strictness would catch more potential issues but also produce many false positives that slow down development.

Example of a rule we skipped:

```javascript
// @typescript-eslint/explicit-function-return-type
function calculateTotal(items: Item[]) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Strict mode requires:
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

TypeScript can infer the return type. Requiring explicit types everywhere is safer but more verbose. For this project, we trust inference. On a large team project with frequent API changes, we'd enable this rule.

### Unused Variables as Warnings, Not Errors

```javascript
'@typescript-eslint/no-unused-vars': ['warn', {
  argsIgnorePattern: '^_',
  varsIgnorePattern: '^_',
}]
```

We downgraded unused variables from errors to warnings. Why?

**During development**, you often declare variables you'll use later. Making this an error would break the commit workflow constantly. Warnings let you commit work-in-progress code while still flagging the issue.

**The pattern `^_`** allows intentional unused variables:

```typescript
function handleClick(_event: MouseEvent) {
  // Don't need event, but TypeScript requires the parameter
  console.log('Clicked!');
}
```

Prefixing with `_` signals "this is intentionally unused" to both ESLint and human readers.

In production code, we'd fix or acknowledge all warnings. But for a small project, warnings are sufficient.

### Prettier printWidth: 100, Not 80

```json
{
  "printWidth": 100
}
```

Traditional wisdom says 80 characters per line, dating back to punch cards. Modern monitors are wider. We chose 100 because:

- Modern screens can easily display 100 characters
- Svelte components often have longer lines due to HTML attributes
- 80 characters forces awkward line breaks in TypeScript generics

**Could we have chosen 80?** Sure. It's more compatible with side-by-side editing. But for this project, readability on a single monitor mattered more.

### Committing .vscode/settings.json

Many projects gitignore `.vscode/` entirely to avoid forcing editor configuration on developers. We committed `settings.json` and `extensions.json`.

**Why?**

1. This is a solo project (plus AI assistants). There's no one to impose settings on.
2. Settings are purely additive - they don't override global VS Code preferences
3. New developers (or future me) get a working setup instantly
4. The settings are minimal and non-controversial (format on save, ESLint auto-fix)

On a large team with diverse editor preferences, we'd probably gitignore this and document recommended settings in `DEVELOPING.md` instead.

### No CommitLint

We didn't set up [commitlint](https://commitlint.js.org/) to enforce commit message conventions. Why not?

**Reason**: This project uses squash-and-merge. Individual commits don't matter because they're collapsed into one commit on the main branch. The PR title becomes the commit message, and we review that manually.

If we used a merge-commit workflow where every commit message appears in the main branch history, we'd add commitlint.

## What You Should Learn From This

### 1. Automation Pays for Itself

**Principle**: Any manual process that happens more than 10 times should be automated.

Code quality checks happen hundreds of times during development. Spending 2 hours setting up automation saves hundreds of hours of manual linting and style debates.

**When to use**:

- Any repetitive task (testing, linting, formatting)
- Any task humans forget to do (running checks before commits)
- Any task that needs to be consistent (style enforcement)

**When to avoid**:

- One-off scripts that won't be reused
- Processes that require human judgment (code review, architecture decisions)

### 2. Tools Should Have Clear Boundaries

**Principle**: Each tool should do one thing well. Overlapping responsibilities create conflicts.

- ESLint: Code quality and bug detection
- Prettier: Code formatting
- Husky: Git hooks
- lint-staged: Performance optimization

They integrate beautifully because they don't step on each other's toes.

**When designing systems**, assign clear responsibilities. If two components both try to solve the same problem, they'll conflict.

### 3. Fail Fast, Fail Clearly

**Principle**: Catch errors as early as possible with clear error messages.

Our system catches issues:

1. In the editor (immediate feedback while typing)
2. On save (ESLint + Prettier auto-fix)
3. On commit (pre-commit hook enforcement)
4. In CI (final safety net)

Each layer provides faster feedback than the next. Editor feedback is instant. CI feedback takes minutes. The earlier you catch issues, the cheaper they are to fix.

**When to use**:

- Validation: Fail immediately on invalid input
- Type checking: Fail at compile time, not runtime
- Testing: Fail during development, not in production

**When to avoid**:

- User-facing errors: Don't fail fast - handle errors gracefully
- Non-critical issues: Warnings are sometimes better than errors

### 4. Configuration is Code

**Principle**: Treat configuration files with the same care as application code.

ESLint v9's flat config makes this explicit. Configuration is JavaScript with imports, variables, and functions. This means:

- You can use comments to explain decisions
- You can extract reusable parts
- You can programmatically generate configuration
- You get IDE autocomplete and type checking

**Example**:

```javascript
const commonRules = {
  '@typescript-eslint/no-unused-vars': 'warn',
};

export default [
  {
    files: ['**/*.ts'],
    rules: commonRules,
  },
  {
    files: ['**/*.svelte'],
    rules: {
      ...commonRules,
      'svelte/no-unused-svelte-ignore': 'error',
    },
  },
];
```

This is much more maintainable than duplicating rules in JSON.

### 5. Opinionated Tools End Debates

**Principle**: When the right answer is subjective, pick one and move on.

Prettier is opinionated by design. It doesn't let you configure every detail. This is a strength, not a weakness.

Style debates waste time:

- "Should we use semicolons?" (4 hours of discussion)
- "Tabs or spaces?" (6 hours of discussion)
- "Single or double quotes?" (2 hours of discussion)

Prettier's answer: "I've decided for you. Move on."

**When to use opinionated tools**:

- Formatting and style
- Standard project structure
- Common workflows

**When to avoid**:

- Domain-specific logic
- Business rules
- User-facing design

### 6. Layer Safety Nets

**Principle**: Multiple layers of protection are better than one perfect layer.

Our quality enforcement has four layers:

1. Editor integration (fastest, optional)
2. Format on save (fast, optional)
3. Pre-commit hooks (enforced, local)
4. CI checks (enforced, remote)

If you bypass the editor and commit from the command line, the pre-commit hook still catches issues. If you commit with `--no-verify`, CI still catches issues.

**When designing safety-critical systems**, use defense in depth. Don't rely on a single point of failure.

## Going Deeper

### Documentation

- [ESLint Configuration Guide](https://eslint.org/docs/latest/use/configure/)
- [ESLint Flat Config Migration](https://eslint.org/docs/latest/use/configure/migration-guide)
- [Prettier Options](https://prettier.io/docs/en/options.html)
- [Husky Documentation](https://typicode.github.io/husky/)
- [lint-staged Documentation](https://github.com/okonet/lint-staged)

### Related Concepts

- **CI/CD pipelines**: Extend quality checks to continuous integration
- **Git hooks**: pre-push, pre-rebase, and other automation opportunities
- **EditorConfig**: Another layer of editor consistency
- **Type checking**: TypeScript's role in catching errors ESLint misses

### Books and Articles

- [Clean Code](https://www.oreilly.com/library/view/clean-code-a/9780136083238/) by Robert C. Martin - Principles behind many ESLint rules
- [Refactoring](https://martinfowler.com/books/refactoring.html) by Martin Fowler - Understanding code smells that linters detect

## Questions to Think About

1. **When would you disable a pre-commit hook?** What scenarios justify `git commit --no-verify`? How do you prevent this from becoming a habit?

2. **How strict should linting rules be on a solo project vs a team project?** What changes as team size grows?

3. **What if Prettier's formatting doesn't match your preference?** When should you configure Prettier vs when should you accept its defaults?

4. **How do you balance automation with flexibility?** When is it okay to let developers bypass rules?

5. **What's the difference between a linting error and a warning?** When should each be used?

6. **How would you extend this system for a monorepo with multiple subprojects?** How would configuration be shared?

7. **What quality checks belong in pre-commit hooks vs CI?** What's too slow for pre-commit? What's too important to skip?
