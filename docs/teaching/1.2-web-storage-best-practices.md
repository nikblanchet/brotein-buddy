# Web Storage Best Practices: Error Handling, Validation, and Migrations

**Deliverable:** 1.2 - LocalStorage Abstraction Layer
**Author:** Claude Code
**Date:** 2025-10-26
**Skill Level:** Intermediate

---

## Table of Contents

1. [Introduction](#introduction)
2. [Web Storage Fundamentals](#web-storage-fundamentals)
3. [LocalStorage vs IndexedDB: Choosing the Right Tool](#localstorage-vs-indexeddb-choosing-the-right-tool)
4. [Storage Layer Architecture](#storage-layer-architecture)
5. [Error Handling Patterns](#error-handling-patterns)
6. [Validation at Storage Boundaries](#validation-at-storage-boundaries)
7. [Migration Framework Design](#migration-framework-design)
8. [Testing Storage Code](#testing-storage-code)
9. [Production Considerations](#production-considerations)
10. [References and Further Reading](#references-and-further-reading)

---

## Introduction

Web applications need to persist data between sessions. While backend databases are the traditional solution, modern web apps increasingly use client-side storage for improved performance, offline capability, and reduced server costs.

This document teaches best practices for implementing robust client-side storage using the browser's Web Storage APIs. We'll cover:

- Choosing between localStorage and IndexedDB
- Building a reliable storage abstraction layer
- Handling errors gracefully
- Validating data at boundaries
- Supporting schema migrations
- Testing storage code thoroughly

### Learning Objectives

By the end of this document, you will understand:

- When to use localStorage vs IndexedDB
- How to design a storage layer that never corrupts user data
- Error handling patterns that degrade gracefully
- Validation strategies for untrusted storage
- Migration frameworks for schema evolution
- Testing approaches for storage code

### Prerequisites

- Intermediate JavaScript/TypeScript
- Basic understanding of JSON
- Familiarity with browser APIs
- Understanding of TypeScript type guards (covered in teaching doc 1.1)

---

## Web Storage Fundamentals

### The Web Storage API

The Web Storage API provides two mechanisms for storing data in the browser:

1. **localStorage** - Persistent storage that survives browser restarts
2. **sessionStorage** - Temporary storage cleared when tab closes

Both share the same API but differ in persistence:

```typescript
// localStorage persists across sessions
localStorage.setItem('key', 'value');
console.log(localStorage.getItem('key')); // 'value'

// sessionStorage clears when tab closes
sessionStorage.setItem('key', 'value');
console.log(sessionStorage.getItem('key')); // 'value' (until tab closes)
```

### Key Characteristics

**Storage capacity:**

- Typically 5-10MB per origin
- Varies by browser and user settings
- QuotaExceededError thrown when limit reached

**Data format:**

- Stores only strings (not objects)
- JSON serialization required for structured data
- Keys and values must be strings

**API type:**

- Synchronous (blocks main thread)
- Simple get/set/remove operations
- No query capabilities

**Scope:**

- Per-origin (protocol + domain + port)
- Shared across all tabs/windows from same origin
- Isolated from other origins (security boundary)

### Basic Usage Pattern

```typescript
// Storing data
const data = { count: 42, name: 'example' };
localStorage.setItem('myData', JSON.stringify(data));

// Loading data
const stored = localStorage.getItem('myData');
if (stored !== null) {
  const parsed = JSON.parse(stored);
  console.log(parsed.count); // 42
}

// Removing data
localStorage.removeItem('myData');

// Clearing all data
localStorage.clear();
```

### Common Pitfalls

**Pitfall 1: Storing objects directly**

```typescript
// Wrong - stores "[object Object]"
localStorage.setItem('data', { count: 42 });
console.log(localStorage.getItem('data')); // "[object Object]"

// Right - serialize first
localStorage.setItem('data', JSON.stringify({ count: 42 }));
const parsed = JSON.parse(localStorage.getItem('data')!);
console.log(parsed.count); // 42
```

**Pitfall 2: Not handling missing data**

```typescript
// Wrong - crashes on missing key
const data = JSON.parse(localStorage.getItem('data'));

// Right - check for null
const stored = localStorage.getItem('data');
const data = stored !== null ? JSON.parse(stored) : defaultValue;
```

**Pitfall 3: Assuming localStorage exists**

```typescript
// Wrong - crashes in some environments
localStorage.setItem('key', 'value');

// Right - check availability
if (typeof localStorage !== 'undefined') {
  localStorage.setItem('key', 'value');
} else {
  console.warn('localStorage not available');
}
```

---

## LocalStorage vs IndexedDB: Choosing the Right Tool

### Decision Matrix

| Factor              | localStorage             | IndexedDB                | Winner       |
| ------------------- | ------------------------ | ------------------------ | ------------ |
| Data size           | < 10MB                   | GBs (50%+ disk)          | IndexedDB    |
| API complexity      | Simple (get/set)         | Complex (async, cursors) | localStorage |
| Query capability    | None (load all)          | Indexes, ranges          | IndexedDB    |
| Transaction support | No                       | Yes                      | IndexedDB    |
| Async/sync          | Sync (blocks)            | Async (non-blocking)     | IndexedDB    |
| Browser support     | 98%+                     | 97%+                     | Tie          |
| Testing complexity  | Easy (jsdom)             | Medium (fake-indexeddb)  | localStorage |
| Learning curve      | 5 minutes                | 2-4 hours                | localStorage |
| Type safety         | Manual (JSON + validate) | Manual (same)            | Tie          |

### When to Choose localStorage

**Use localStorage when:**

- Data size < 1MB (comfortably under 5MB limit)
- Simple key-value storage needs
- Synchronous API acceptable (small data = fast)
- No query requirements (load entire state)
- Simplicity and ease of testing valued
- Quick development iteration needed

**Example use cases:**

- User preferences and settings
- Shopping cart state
- Form draft data
- Small inventory systems (like BroteinBuddy)
- Authentication tokens

### When to Choose IndexedDB

**Use IndexedDB when:**

- Data size > 10MB
- Need structured queries with indexes
- Require transactions for atomic updates
- Working with large datasets that shouldn't block UI
- Need to query without loading all data

**Example use cases:**

- Email clients (thousands of messages)
- Offline-first apps with large datasets
- Media libraries (metadata, not files themselves)
- Complex relational data
- Apps caching API responses at scale

### BroteinBuddy's Choice: localStorage

For BroteinBuddy, localStorage is the clear choice:

**Data size analysis:**

- 50 boxes × ~100 bytes = 5KB
- 20 flavors × ~50 bytes = 1KB
- Metadata and settings: < 1KB
- **Total: < 10KB** (well under 5MB limit)

**Access pattern:**

- Always load entire state on app start
- No need for queries (e.g., "find all open boxes")
- Updates are infrequent (user actions only)

**Simplicity wins:**

- Synchronous API fine for < 10KB
- Easy to test (jsdom provides localStorage)
- No complex migration from async to sync throughout codebase

**Tradeoff accepted:**

- Lost: IndexedDB's power features (not needed)
- Gained: Simplicity, faster development, easier maintenance

---

## Storage Layer Architecture

### Abstraction Principles

**Never access storage directly from application code.** Always use an abstraction layer.

**Why?**

1. **Centralized error handling** - One place to handle all storage errors
2. **Validation at boundary** - Ensure data integrity before entering application
3. **Easy testing** - Mock the abstraction, not browser APIs
4. **Future flexibility** - Swap storage implementation without changing app code
5. **Migration support** - Centralize schema evolution logic

### Three-Layer Architecture

```
┌──────────────────────────────────────┐
│   Application Code                   │  (Svelte components, state management)
│   - Works with valid AppState        │
│   - Assumes data is correct          │
│   - No error handling needed         │
└───────────────┬──────────────────────┘
                │ loadState() / saveState()
                │ (typed, validated data only)
                ↓
┌──────────────────────────────────────┐
│   Storage Abstraction Layer          │  (src/lib/storage.ts)
│   - Validation (isAppState)          │
│   - Error handling                   │
│   - Migration (migrateState)         │
│   - Default state on failure         │
└───────────────┬──────────────────────┘
                │ localStorage.getItem() / setItem()
                │ (raw strings, may be corrupted)
                ↓
┌──────────────────────────────────────┐
│   Browser localStorage               │  (untrusted boundary)
│   - String storage only              │
│   - May be corrupted                 │
│   - May not exist                    │
└──────────────────────────────────────┘
```

### API Design

**Minimal, focused interface:**

```typescript
// Load state (never fails - returns default on error)
export function loadState(): AppState;

// Save state (validates, throws on invalid or quota exceeded)
export function saveState(state: AppState): void;

// Clear all data (for testing and reset)
export function clearState(): void;
```

**Design principles:**

1. **loadState() never fails** - Always returns valid AppState
   - Corrupted data? Return default
   - Missing data? Return default
   - Invalid schema? Return default

2. **saveState() validates first** - Prevents storing invalid data
   - Throws on invalid state (programming error)
   - Throws on quota exceeded (user must act)

3. **Simple, predictable behavior** - No surprises
   - No callbacks, promises, or async complexity
   - Clear error semantics
   - Documented edge cases

### Implementation Example

```typescript
const STORAGE_KEY = 'BROTEINBUDDY_APP_STATE';

export function loadState(): AppState {
  try {
    if (typeof localStorage === 'undefined') {
      console.warn('localStorage not available, using default state');
      return createDefaultAppState();
    }

    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored === null) {
      return createDefaultAppState();
    }

    const parsed: unknown = JSON.parse(stored);
    const migrated = migrateState(parsed);

    if (!isAppState(migrated)) {
      console.warn('Stored data failed validation, using default state');
      return createDefaultAppState();
    }

    return migrated;
  } catch (error) {
    console.warn('Failed to load state from localStorage:', error);
    return createDefaultAppState();
  }
}

export function saveState(state: AppState): void {
  if (!isAppState(state)) {
    throw new Error('Cannot save invalid state: schema validation failed');
  }

  try {
    const serialized = JSON.stringify(state);
    localStorage.setItem(STORAGE_KEY, serialized);
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      console.error('LocalStorage quota exceeded');
      throw error;
    }
    console.error('Failed to save state to localStorage:', error);
    throw error;
  }
}
```

**Key design decisions:**

- **loadState() uses try-catch wrapper** - Any unexpected error returns default state
- **JSON.parse() errors caught** - Corrupted JSON doesn't crash app
- **Validation after migration** - Ensure migrated data is still valid
- **saveState() throws on invalid state** - Programming error, should not happen
- **Quota errors re-thrown** - Caller must handle (show UI notification)

---

## Error Handling Patterns

### Philosophy: Never Lose User Data

**Core principle:** The application should never crash or lose data due to storage issues.

**Error categories:**

1. **Expected errors** (handle gracefully)
   - Missing data (new user, cleared storage)
   - Corrupted data (browser bug, user edit, extension interference)
   - Quota exceeded (show warning, let user free space)

2. **Unexpected errors** (log and degrade)
   - localStorage unavailable (private browsing, browser bug)
   - JSON.parse() exceptions (corrupted data)
   - Unknown DOMExceptions

3. **Programming errors** (throw loudly)
   - Saving invalid state (failed validation)
   - Type mismatches (calling with wrong types)

### Error Handling Matrix

| Error Type               | Action                           | User Impact      |
| ------------------------ | -------------------------------- | ---------------- |
| Missing data             | Return default state             | None (expected)  |
| Corrupted JSON           | Log warning, return default      | Data reset       |
| Invalid schema           | Log warning, return default      | Data reset       |
| Quota exceeded (save)    | Log error, throw exception       | Must free space  |
| localStorage unavailable | Log warning, return default      | Data reset       |
| Invalid state (save)     | Throw error                      | Programming bug  |
| Unknown exception        | Log error, return default (load) | Data reset       |
|                          | Log error, throw (save)          | Operation failed |

### Graceful Degradation Pattern

```typescript
export function loadState(): AppState {
  try {
    // Attempt normal path
    return loadFromStorage();
  } catch (error) {
    // Degrade gracefully - never crash
    console.warn('Storage load failed, using default state:', error);
    return createDefaultAppState();
  }
}
```

**Why this works:**

- Application continues functioning
- User sees empty state (better than crash)
- Error logged for debugging
- User can re-enter data

### Quota Exceeded Handling

**Challenge:** localStorage has limits (typically 5-10MB). When exceeded, `QuotaExceededError` is thrown.

**Strategy:**

```typescript
export function saveState(state: AppState): void {
  // ... validation ...

  try {
    localStorage.setItem(STORAGE_KEY, serialized);
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      console.error('LocalStorage quota exceeded');
      throw error; // Let UI handle this
    }
    // Other errors also thrown (not a silent failure)
    throw error;
  }
}
```

**UI handling:**

```typescript
// In component or state management
try {
  saveState(newState);
} catch (error) {
  if (error instanceof DOMException && error.name === 'QuotaExceededError') {
    alert('Storage full! Please delete old data or clear browser storage.');
  } else {
    alert('Failed to save data. Please try again.');
  }
}
```

**Prevention:**

- Keep data size small (< 1MB target for localStorage)
- Periodically clean old data
- Compress large text (if needed)
- Consider IndexedDB if approaching limits

### Logging Strategy

**Development:**

- Log all errors with full context
- Include stack traces
- Use `console.warn()` for expected errors
- Use `console.error()` for unexpected errors

**Production:**

- Consider error tracking service (Sentry, LogRocket)
- Rate-limit logging to avoid spam
- Include error context (browser, state size, timestamp)
- Privacy: Don't log user data

```typescript
function logStorageError(operation: string, error: unknown): void {
  const errorInfo = {
    operation,
    error: error instanceof Error ? error.message : String(error),
    timestamp: new Date().toISOString(),
    browser: navigator.userAgent,
  };

  console.error('Storage error:', errorInfo);

  // In production, send to error tracking service
  // trackError(errorInfo);
}
```

---

## Validation at Storage Boundaries

### Why Validate?

**localStorage is an untrusted boundary.** Data can be corrupted by:

- Browser bugs or crashes
- User editing with dev tools
- Browser extensions interfering
- Malicious scripts (XSS vulnerabilities in other sites on same origin)
- Schema changes (old version data)

**Never trust data from storage.** Always validate before using.

### Validation Strategies

**Option 1: Type Guards (BroteinBuddy's choice)**

Pros:

- Simple boolean check (valid or not)
- No dependencies
- Consistent with existing codebase
- Fast execution

Cons:

- Basic error messages
- No data transformation
- Manual implementation

```typescript
export function isAppState(value: unknown): value is AppState {
  return (
    typeof value === 'object' &&
    value !== null &&
    'version' in value &&
    'boxes' in value &&
    'flavors' in value &&
    // ... full validation ...
    (value as AppState).boxes.every(isBox) &&
    (value as AppState).flavors.every(isFlavor)
  );
}

// Usage
const parsed: unknown = JSON.parse(stored);
if (isAppState(parsed)) {
  // TypeScript knows parsed is AppState
  return parsed;
} else {
  // Invalid data, return default
  return createDefaultAppState();
}
```

**Option 2: Zod**

Pros:

- Detailed error messages
- Data transformation/coercion
- Type inference from schemas
- Standard library

Cons:

- External dependency (14KB)
- More complex setup
- Overkill for simple validation

```typescript
import { z } from 'zod';

const AppStateSchema = z.object({
  version: z.number().int().positive(),
  boxes: z.array(BoxSchema),
  flavors: z.array(FlavorSchema),
  favoriteFlavorId: z.string().nullable(),
  settings: z.record(z.unknown()),
});

// Usage
try {
  const parsed = AppStateSchema.parse(JSON.parse(stored));
  return parsed; // typed as AppState
} catch (error) {
  console.warn('Validation failed:', error.message);
  return createDefaultAppState();
}
```

**Option 3: JSON Schema**

Similar to Zod but older standard. Less TypeScript-friendly.

### Validation Depth

**Deep validation** (BroteinBuddy approach):

```typescript
export function isAppState(value: unknown): value is AppState {
  return (
    // ... top-level fields ...
    (value as AppState).boxes.every(isBox) && // Validate every box
    (value as AppState).flavors.every(isFlavor) // Validate every flavor
  );
}
```

**Shallow validation** (faster but risky):

```typescript
// Only check top-level structure, assume contents valid
export function isAppStateShallow(value: unknown): value is AppState {
  return (
    typeof value === 'object' &&
    value !== null &&
    'boxes' in value &&
    Array.isArray((value as AppState).boxes)
  );
}
```

**Recommendation:** Use deep validation for critical data. The performance cost is negligible for small datasets.

### Validation Performance

For BroteinBuddy (< 10KB data):

- Deep validation: ~1ms
- Impact: Negligible (app startup only)

For larger datasets:

- Consider shallow validation for frequent operations
- Deep validation only on initial load
- Cache validation results if data immutable

---

## Migration Framework Design

### Why Migrations?

Applications evolve. Your data schema will change:

- **Adding features:** New fields (e.g., `favoriteFlavorId` added in v2)
- **Refactoring:** Renamed or restructured fields
- **Deprecation:** Removing old unused fields
- **Bug fixes:** Correcting malformed data from earlier versions

**Without migrations:**

- Old data becomes invalid
- Users lose their data
- App crashes on startup

**With migrations:**

- Old data transformed to new schema
- Users retain their data
- Smooth upgrade experience

### Schema Versioning

**Include version field in root schema:**

```typescript
export interface AppState {
  version: number; // Schema version
  boxes: Box[];
  flavors: Flavor[];
  // ... other fields ...
}
```

**Version semantics:**

- Start at 1 (not 0 - easier to detect unversioned old data)
- Increment on any schema change
- Document changes in migration code

### Migration Framework Pattern

```typescript
function migrateState(data: unknown): unknown {
  // Handle completely invalid data
  if (typeof data !== 'object' || data === null) {
    return data; // Will fail validation, return default state
  }

  const versioned = data as { version?: number };

  // Unversioned data (pre-migration system)
  if (!('version' in versioned)) {
    return migrateFromUnversioned(data);
  }

  // Apply migrations sequentially
  let current = data;
  if (versioned.version === 1) {
    current = migrateV1ToV2(current);
  }
  if ((current as { version: number }).version === 2) {
    current = migrateV2ToV3(current);
  }
  // ... future versions ...

  return current;
}
```

### Migration Examples

**Example 1: Adding a field**

```typescript
// v1 -> v2: Add favoriteFlavorId field
function migrateV1ToV2(data: unknown): unknown {
  const v1 = data as {
    version: 1;
    boxes: Box[];
    flavors: Flavor[];
    settings: Record<string, unknown>;
  };

  return {
    ...v1,
    version: 2,
    favoriteFlavorId: null, // New field with default value
  };
}
```

**Example 2: Renaming a field**

```typescript
// v2 -> v3: Rename 'favoriteFlavorId' to 'quickPickFlavorId'
function migrateV2ToV3(data: unknown): unknown {
  const v2 = data as {
    version: 2;
    boxes: Box[];
    flavors: Flavor[];
    favoriteFlavorId: string | null;
    settings: Record<string, unknown>;
  };

  const { favoriteFlavorId, ...rest } = v2;

  return {
    ...rest,
    version: 3,
    quickPickFlavorId: favoriteFlavorId, // Renamed field
  };
}
```

**Example 3: Restructuring data**

```typescript
// v3 -> v4: Split Location into separate x/y instead of stack/height
function migrateV3ToV4(data: unknown): unknown {
  const v3 = data as {
    version: 3;
    boxes: Array<{
      id: string;
      location: { stack: number; height: number };
      // ... other fields ...
    }>;
    // ... other fields ...
  };

  return {
    ...v3,
    version: 4,
    boxes: v3.boxes.map((box) => ({
      ...box,
      location: {
        x: box.location.stack,
        y: box.location.height,
      },
    })),
  };
}
```

### Migration Testing

**Critical:** Test every migration path.

```typescript
describe('migrations', () => {
  it('should migrate from v1 to v2', () => {
    const v1Data = {
      version: 1,
      boxes: [],
      flavors: [],
      settings: {},
    };

    const migrated = migrateState(v1Data);

    expect(migrated).toEqual({
      version: 2,
      boxes: [],
      flavors: [],
      favoriteFlavorId: null, // Added field
      settings: {},
    });
  });

  it('should migrate from v1 to current (through all versions)', () => {
    const v1Data = createV1Data();
    const migrated = migrateState(v1Data);

    expect(isAppState(migrated)).toBe(true);
    expect((migrated as AppState).version).toBe(CURRENT_VERSION);
  });

  it('should preserve data through migrations', () => {
    const v1Data = {
      version: 1,
      boxes: [{ id: 'box1' /* ... */ }],
      flavors: [{ id: 'flavor1' /* ... */ }],
    };

    const migrated = migrateState(v1Data) as AppState;

    expect(migrated.boxes[0].id).toBe('box1');
    expect(migrated.flavors[0].id).toBe('flavor1');
  });
});
```

### Migration Best Practices

1. **Sequential migrations** - Apply each version change in order
2. **Preserve data** - Never delete user data unless absolutely necessary
3. **Test migration paths** - Test v1→v2, v1→current, v2→current, etc.
4. **Document changes** - Comment each migration with date and rationale
5. **Idempotent if possible** - Running migration twice should be safe
6. **Validate after migration** - Ensure migrated data passes current schema validation

---

## Testing Storage Code

### Why 100% Coverage?

Storage code is a **critical path** - data loss is unacceptable. Aim for 100% coverage.

**Test coverage should include:**

- All normal paths (save, load, clear)
- All error paths (corrupted data, quota exceeded)
- Edge cases (missing localStorage, empty strings)
- Integration scenarios (save→load cycles)

### Testing Environment Setup

**Vitest with jsdom:**

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom', // Provides localStorage
    globals: true,
  },
});
```

**jsdom provides:**

- Full localStorage implementation
- Automatic cleanup between tests
- Quota simulation (limited)

### Test Structure

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { loadState, saveState, clearState } from './storage';

describe('storage', () => {
  beforeEach(() => {
    localStorage.clear(); // Clean slate for each test
  });

  afterEach(() => {
    vi.restoreAllMocks(); // Restore any spies/mocks
  });

  describe('loadState', () => {
    // Test cases for loading...
  });

  describe('saveState', () => {
    // Test cases for saving...
  });

  describe('clearState', () => {
    // Test cases for clearing...
  });
});
```

### Testing Normal Paths

```typescript
it('should load valid state from localStorage', () => {
  const validState: AppState = {
    version: 1,
    boxes: [{ id: 'box1' /* ... */ }],
    flavors: [],
    favoriteFlavorId: null,
    settings: {},
  };

  localStorage.setItem('BROTEINBUDDY_APP_STATE', JSON.stringify(validState));

  const loaded = loadState();
  expect(loaded).toEqual(validState);
});

it('should save valid state to localStorage', () => {
  const state = createDefaultAppState();

  saveState(state);

  const stored = localStorage.getItem('BROTEINBUDDY_APP_STATE');
  expect(stored).not.toBeNull();
  expect(JSON.parse(stored!)).toEqual(state);
});
```

### Testing Error Paths

**Corrupted JSON:**

```typescript
it('should return default state when JSON is corrupted', () => {
  const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

  localStorage.setItem('BROTEINBUDDY_APP_STATE', 'invalid json {{{');

  const state = loadState();

  expect(state).toEqual(createDefaultAppState());
  expect(consoleSpy).toHaveBeenCalled();

  consoleSpy.mockRestore();
});
```

**Invalid schema:**

```typescript
it('should return default state when schema is invalid', () => {
  const invalidState = {
    // Missing version field
    boxes: [],
    flavors: [],
  };

  localStorage.setItem('BROTEINBUDDY_APP_STATE', JSON.stringify(invalidState));

  const state = loadState();
  expect(state).toEqual(createDefaultAppState());
});
```

**Quota exceeded:**

```typescript
it('should handle quota exceeded error', () => {
  const quotaError = new DOMException('Quota exceeded', 'QuotaExceededError');

  vi.spyOn(Storage.prototype, 'setItem').mockImplementation(() => {
    throw quotaError;
  });

  const state = createDefaultAppState();

  expect(() => saveState(state)).toThrow(DOMException);
});
```

**localStorage unavailable:**

```typescript
it('should handle localStorage being unavailable', () => {
  const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

  // Mock localStorage as undefined
  const originalLocalStorage = global.localStorage;
  Object.defineProperty(global, 'localStorage', {
    value: undefined,
    writable: true,
  });

  const state = loadState();

  expect(state).toEqual(createDefaultAppState());

  // Restore localStorage
  Object.defineProperty(global, 'localStorage', {
    value: originalLocalStorage,
    writable: true,
  });

  consoleSpy.mockRestore();
});
```

### Testing Integration Scenarios

```typescript
it('should persist state across save and load', () => {
  const originalState: AppState = {
    version: 1,
    boxes: [{ id: 'box1' /* ... */ }, { id: 'box2' /* ... */ }],
    flavors: [{ id: 'flavor1' /* ... */ }],
    favoriteFlavorId: 'flavor1',
    settings: {},
  };

  saveState(originalState);
  const loaded = loadState();

  expect(loaded).toEqual(originalState);
});

it('should return default state after clearing', () => {
  const state = createDefaultAppState();
  state.boxes.push({ id: 'box1' /* ... */ });

  saveState(state);
  expect(loadState().boxes).toHaveLength(1);

  clearState();

  const loaded = loadState();
  expect(loaded).toEqual(createDefaultAppState());
  expect(loaded.boxes).toHaveLength(0);
});
```

### Coverage Verification

```bash
npm run test:coverage

# Output should show:
# storage.ts: 100% statements, branches, functions, lines
```

**If coverage < 100%:**

- Check which lines are uncovered
- Add tests for those paths
- Ensure all error handlers tested
- Verify edge cases covered

---

## Production Considerations

### Performance

**localStorage is synchronous** - blocks main thread during operations.

**Mitigation strategies:**

1. **Keep data small** (< 100KB recommended for localStorage)
   - Minimize JSON verbosity
   - Don't store large text blobs
   - Consider compression for larger data

2. **Batch saves** - Avoid saving on every tiny change
   - Debounce saves (e.g., save 500ms after last change)
   - Or save only on meaningful events (navigation, blur)

3. **Load once** - Don't repeatedly read from storage
   - Load on app startup
   - Keep state in memory (Svelte stores, Redux, etc.)
   - Save on changes, load only on startup

**Performance example:**

```typescript
// Bad: Reads from storage on every access
function getBoxCount(): number {
  const state = loadState();
  return state.boxes.length;
}

// Good: Load once, keep in memory
const state = loadState(); // On app startup
function getBoxCount(): number {
  return state.boxes.length;
}
```

### Security

**localStorage is NOT secure storage:**

- Readable by any JavaScript on your origin
- Vulnerable to XSS attacks
- Persists across sessions (security risk for shared devices)

**Do NOT store:**

- Passwords or credentials
- Sensitive personal data (SSN, credit cards)
- API keys or secrets
- Anything that would harm user if leaked

**For sensitive data:**

- Use server-side storage
- Or encrypt before storing (but key management is hard)
- Consider sessionStorage (clears on tab close)

### Privacy and Compliance

**GDPR considerations:**

- localStorage data persists indefinitely
- Users should be able to clear their data
- Consider implementing "delete all data" feature

```typescript
// Provide clear data option in UI
function deleteAllUserData(): void {
  clearState();
  // Also clear any other stored data
  alert('All your data has been deleted.');
}
```

**User transparency:**

- Document what data is stored locally
- Explain that data stays on device
- Provide easy way to export/clear data

### Cross-Browser Compatibility

**localStorage support:** 98%+ globally (safe to use)

**Edge cases to handle:**

1. **Private/Incognito mode** - Some browsers disable or clear storage
2. **Safari in iframe** - May block storage in cross-origin iframes
3. **Quota limits** - Vary by browser (5MB, 10MB, or more)

**Detection pattern:**

```typescript
export function isLocalStorageAvailable(): boolean {
  try {
    const test = '__storage_test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch (e) {
    return false;
  }
}
```

### Monitoring and Analytics

**Track storage errors in production:**

```typescript
function trackStorageError(error: unknown): void {
  // Send to analytics service
  analytics.track('storage_error', {
    error: error instanceof Error ? error.message : String(error),
    userAgent: navigator.userAgent,
    timestamp: Date.now(),
  });
}
```

**Metrics to monitor:**

- Storage errors per user
- Quota exceeded frequency
- Average state size
- Load/save latency

### Debugging Tips

**View localStorage in DevTools:**

- Chrome/Edge: Application tab → Local Storage
- Firefox: Storage tab → Local Storage
- Safari: Storage tab → Local Storage

**Clear storage during development:**

```typescript
// Add to dev tools console
clearState();
location.reload();
```

**Debug logging:**

```typescript
function loadState(): AppState {
  console.group('loadState');
  console.time('loadState');

  // ... implementation ...

  console.timeEnd('loadState');
  console.log('Loaded state:', state);
  console.groupEnd();

  return state;
}
```

---

## References and Further Reading

### Official Documentation

- [MDN: Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)
- [MDN: Window.localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
- [MDN: IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)

### Browser Support

- [Can I Use: Web Storage](https://caniuse.com/namevalue-storage)
- [Can I Use: IndexedDB](https://caniuse.com/indexeddb)

### Related ADRs (BroteinBuddy)

- ADR-001: Technology Stack Selection
- ADR-002: Data Model Design
- ADR-003: LocalStorage Strategy

### Related Teaching Documents

- 1.1: Type-Driven Design (type guards for validation)
- 0.2: Testing Philosophy (testing strategies)

### Libraries Referenced

- [Zod](https://zod.dev/) - TypeScript-first schema validation
- [Vitest](https://vitest.dev/) - Testing framework
- [jsdom](https://github.com/jsdom/jsdom) - DOM implementation for testing

---

## Summary

**Key Takeaways:**

1. **Choose the right tool** - localStorage for small data (< 1MB), IndexedDB for large or complex data
2. **Abstract storage access** - Never access localStorage directly from application code
3. **Validate at boundaries** - Storage is untrusted, always validate before using
4. **Handle errors gracefully** - Never crash due to storage issues, degrade gracefully
5. **Plan for migrations** - Schema will evolve, build migration framework from day one
6. **Test thoroughly** - Aim for 100% coverage on storage code (critical path)
7. **Keep it simple** - Don't over-engineer for problems you don't have yet

**Architecture Checklist:**

- [ ] Storage abstraction layer isolates storage from app code
- [ ] loadState() never fails (returns default on error)
- [ ] saveState() validates before saving
- [ ] All errors handled gracefully
- [ ] Validation uses type guards or schema library
- [ ] Migration framework in place (even if unused initially)
- [ ] Tests cover all error paths
- [ ] 100% test coverage on storage module
- [ ] Documentation explains storage decisions (ADR)
- [ ] Production monitoring for storage errors

By following these patterns, you'll build a robust storage layer that protects user data, handles errors gracefully, and scales as your application grows.

---

**Document Version:** 1.0
**Last Updated:** 2025-10-26
**Related Deliverable:** Phase 1, Step 1.2 - LocalStorage Abstraction Layer
