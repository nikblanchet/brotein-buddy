# Architecture Decision Records: Documenting Design Choices for Future You

## What We Built

In deliverable 0.7, we established a comprehensive documentation system for recording architectural and design decisions. This included creating a `docs/adr/` directory structure, developing a detailed ADR template that captures context, decisions, consequences, and alternatives, and writing our first ADR documenting the technology stack selection (Svelte, TypeScript, LocalStorage, PWA). We also integrated ADR guidance into DEVELOPING.md, explaining when to write ADRs and how to maintain them over time.

This system serves as a time capsule for our decision-making process, helping future developers (including future you) understand not just what decisions were made, but why they were made and what alternatives were considered.

## Why ADRs Matter

### The Problem: Institutional Amnesia

Six months from now, when you're staring at code you wrote and thinking "Why did I do it this way?", you'll have two options:

1. Spend hours reconstructing your reasoning from git commits, Stack Overflow searches, and vague memories
2. Open the ADR and read exactly why you made that choice

Without ADRs, every project eventually suffers from institutional amnesia. Team members leave, memories fade, and seemingly bizarre decisions remain unexplained. Even solo developers forget their own reasoning surprisingly quickly.

### What ADRs Provide

An Architecture Decision Record is a lightweight document that captures:

- **Context**: What situation prompted this decision?
- **Decision**: What did we decide to do?
- **Consequences**: What are the trade-offs (good, bad, neutral)?
- **Alternatives**: What else did we consider and why didn't we choose it?

The format was popularized by Michael Nygard in 2011 and has become a widely-adopted practice in software development. The key insight: documentation should focus on decisions and their rationale, not just describing what the code does.

### For Solo Developers

"But I'm working alone, I'll remember my decisions!"

Three reasons that's wishful thinking:

1. **Memory fades faster than you think**: Try remembering why you chose a specific library six months ago. Was it bundle size? TypeScript support? A specific feature you needed? You probably can't recall.

2. **Context switching destroys continuity**: Work on three other projects, then come back to this one. Without ADRs, you're essentially a new team member onboarding yourself.

3. **Future you is a different person**: Your skills evolve, your preferences change, industry best practices shift. Future you needs to understand what past you was thinking.

### For Teams

For teams, ADRs are even more critical:

- **Onboarding**: New team members can understand past decisions without interrogating everyone
- **Avoiding rehashing**: "Why don't we use React?" - "See ADR-001"
- **Distributed decision-making**: Remote teams need shared context
- **Accountability**: Decisions are transparent and traceable
- **Learning**: Failed decisions become teaching moments, not mysteries

## When to Write an ADR

### Good Candidates for ADRs

Write an ADR when making decisions that are:

1. **Architecturally significant**
   - Choosing frameworks or libraries (React vs Svelte vs Vue)
   - Selecting databases or storage mechanisms (PostgreSQL vs MongoDB vs LocalStorage)
   - Deciding on deployment platforms (AWS vs Vercel vs Netlify)

2. **Difficult or expensive to reverse**
   - Committing to a monorepo structure
   - Choosing GraphQL vs REST for your API
   - Selecting a state management approach

3. **Affecting multiple components**
   - Error handling conventions
   - Authentication strategy
   - Logging and observability approach

4. **Involving significant trade-offs**
   - Performance vs simplicity
   - Type safety vs flexibility
   - Build-time vs runtime decisions

5. **Likely to be questioned later**
   - "Why don't we use [popular technology X]?"
   - "Why did we build this instead of using [library Y]?"
   - "Why is our setup so complicated/simple?"

### Examples from BroteinBuddy

**Good ADR candidates:**

- Technology stack selection (Svelte, TypeScript, LocalStorage) âœ… We wrote ADR-001
- State management approach (Svelte stores vs Zustand vs Redux)
- Testing strategy (coverage requirements, test organization)
- Data model design (normalized vs denormalized)
- PWA configuration decisions

**Not worth an ADR:**

- Naming a specific variable
- Choosing between `const` and `let` in a specific case
- File organization within a single component
- CSS class naming in one-off situations

### When Other Documentation is Better

ADRs aren't the only documentation format. Here's when to use alternatives:

**Code comments** - For:

- Explaining non-obvious implementation details
- Documenting why you worked around a bug
- Clarifying complex algorithms
- Warning about edge cases

```typescript
// Using a Map instead of Object because we need to preserve
// insertion order for the drag-and-drop feature (ADR-042)
const boxPositions = new Map<string, Location>();
```

Notice the code comment can reference an ADR for deeper context.

**README** - For:

- User-facing documentation
- How to install and use the application
- Quick-start guides
- Project overview for newcomers

**DEVELOPING.md** - For:

- Development workflow and setup
- How to run tests
- Git conventions
- Tool configuration

**Inline documentation (JSDoc/TSDoc)** - For:

- API contracts
- Function parameters and return types
- Usage examples

**ADRs** - For:

- Why decisions were made
- Trade-offs between approaches
- Historical context
- Alternatives considered

The key difference: ADRs focus on the "why" and "what else," while other docs focus on "what" and "how."

## The Anatomy of a Good ADR

Let's walk through our template section by section, using ADR-001 (Technology Stack Selection) as an example.

### Header: Metadata

```markdown
# ADR-001: Technology Stack Selection

**Status:** Accepted

**Date:** 2025-10-25

**Deciders:** Development team
```

**What this tells us:**

- **Number**: Sequential numbering (001, 002, 003...) creates a timeline
- **Title**: Short, descriptive (kebab-case in filename: `001-technology-stack-selection.md`)
- **Status**: Shows the ADR's current state
  - Proposed: Under discussion
  - Accepted: Decision made and implemented
  - Deprecated: No longer valid
  - Superseded by ADR-XXX: Replaced by a newer decision
- **Date**: When was this decided? (Not written, decided!)
- **Deciders**: Who was involved? (For teams; solo devs can just write "Development team" or your name)

The status field is particularly important. As your project evolves, decisions change. Marking ADRs as deprecated or superseded maintains the historical record while clarifying what's currently valid.

### Context: The Forces at Play

```markdown
## Context

BroteinBuddy is a personal utility application for tracking protein
shake inventory by flavor and location. The application needs to:

- Provide a mobile-first, touch-friendly interface
- Work offline without requiring a backend server
- Be installable on iOS devices as a Progressive Web App
- Support visual inventory management with drag-and-drop
- Persist data locally on the user's device
- Enable rapid development with strong type safety

### Background

This is a personal portfolio project demonstrating modern web
development practices...

### Problem Statement

We need to select a technology stack that:

- Enables rapid UI development with minimal boilerplate
- Provides strong type safety to catch errors early
- ...
```

The Context section answers: "What's the situation that led to this decision?"

**Three subsections:**

1. **Context** (main): High-level situation and constraints
2. **Background**: Additional details that provide perspective
3. **Problem Statement**: Specific requirements or constraints

**Why this matters:** Decisions don't happen in a vacuum. In ADR-001, we needed offline-first PWA functionality. That constraint immediately ruled out certain approaches (server-side rendering, traditional mobile apps) and made others more attractive (LocalStorage, service workers).

Five years from now, web development will be different. What if PWAs fall out of favor and native apps make a comeback? This Context section explains why PWAs made sense for our situation in 2025.

### Decision: What We're Doing

```markdown
## Decision

We will use the following technology stack:

**Frontend Framework:** Svelte 5 + TypeScript
**Build Tool:** Vite
**Testing:**

- Vitest for unit and integration tests
- Playwright for end-to-end tests
- @testing-library/svelte for component testing

**Data Persistence:** LocalStorage
**Deployment:** Vercel with GitHub Actions CI/CD
**Progressive Web App:** PWA manifest + service worker

### Implementation Details

**Development Environment:**

- TypeScript strict mode enabled
- ESLint + Prettier for code quality
- Husky for pre-commit hooks
- Git worktrees for parallel development
```

The Decision section is written in **active voice**, present tense: "We will use..." not "We might consider..." or "It was decided that..."

**Be specific.** Don't just say "We'll use a modern framework," say "We'll use Svelte 5." Don't just say "We'll test our code," specify Vitest for unit tests, Playwright for E2E.

**Implementation Details subsection** is optional but useful for decisions that have specific technical requirements. In our case, we wanted to document that we're using TypeScript strict mode and git worktrees, as these are part of the technology stack decision.

### Consequences: The Trade-offs

```markdown
## Consequences

### Positive

- **Svelte 5**: Minimal boilerplate, reactive by default, excellent
  performance, smaller bundle sizes than React/Vue
- **TypeScript**: Strong type safety catches errors at compile time
- **Vite**: Near-instant dev server startup, fast HMR
- **LocalStorage**: Zero backend infrastructure, works offline by default
- ...

### Negative

- **Svelte 5**: Smaller ecosystem than React, fewer third-party components
- **LocalStorage**: Limited to ~5-10MB storage, no cross-device sync
- **No Backend**: Cannot implement server-side features
- **PWA on iOS**: Limited compared to native apps
- ...

### Neutral

- **Client-Only Architecture**: Appropriate for single-user utility but
  would require rearchitecture for multi-user features
- **Vercel Deployment**: Free tier sufficient but vendor lock-in if
  requirements change
```

This is the most important section for future you.

**List ALL consequences, not just the positives.** Every decision has trade-offs. Being honest about the negatives shows maturity and helps future developers understand what compromises were made.

**Three categories:**

1. **Positive**: What benefits does this provide?
2. **Negative**: What drawbacks or constraints does this create?
3. **Neutral**: What changes that's neither clearly good nor bad?

Notice how we're honest in ADR-001: Yes, Svelte 5 has great performance, but it also has a smaller ecosystem than React. Yes, LocalStorage is simple, but we're limited to ~10MB and no cross-device sync.

This prevents future second-guessing. When someone asks "Why didn't we use React?", the answer isn't "We didn't think of it" - the answer is "We explicitly chose Svelte because X, Y, Z, and we accepted trade-offs A, B, C."

### Alternatives Considered: What We Didn't Choose

```markdown
## Alternatives Considered

### Alternative 1: React + TypeScript

**Description:** Use React 18 with TypeScript, create-react-app or
Vite, React Testing Library

**Pros:**

- Larger ecosystem and community
- More third-party components available
- More familiar to potential employers

**Cons:**

- More boilerplate code (hooks, useState, useEffect)
- Larger bundle sizes
- More complex reactivity model

**Why not chosen:** Svelte's simpler syntax and better performance
are more valuable for this project than React's ecosystem size.
```

This section prevents endless "Have you considered...?" questions.

For each alternative:

1. **Describe it concretely** - Not just "Other frameworks" but specifically "React + TypeScript"
2. **List pros AND cons** - Be fair to the alternatives
3. **Explain why you didn't choose it** - This is the key learning

In ADR-001, we considered five alternatives:

- React + TypeScript
- Vue 3 + TypeScript
- IndexedDB for storage
- Backend + Database (Supabase, Firebase)
- Native Mobile App (React Native, Flutter)

For each, we honestly assessed the benefits and explained our reasoning. This prevents future debates: "We already considered IndexedDB in ADR-001 and decided against it because our data is small enough for LocalStorage."

### References: Where to Learn More

```markdown
## References

- [Svelte 5 Documentation](https://svelte.dev/)
- [Vite Documentation](https://vitejs.dev/)
- [PWA Best Practices](https://web.dev/progressive-web-apps/)
- [LocalStorage vs IndexedDB](https://web.dev/storage-for-the-web/)
- [Vitest Documentation](https://vitest.dev/)
- [Playwright Documentation](https://playwright.dev/)
```

Link to:

- Related ADRs in your project
- External documentation
- Blog posts or articles that influenced the decision
- Discussion threads or GitHub issues
- Research papers or books

This helps future developers (or you) dive deeper when needed.

## How to Write Effective ADRs

### Start with a Brain Dump

Don't try to write the perfect ADR immediately. Start with a rough outline:

```markdown
# ADR-XXX: Use LocalStorage for Data Persistence

Context:

- Need to store boxes and flavors
- No backend, offline-first
- Small data size (~1KB to 100KB max)

Decision:

- Use LocalStorage
- Simple key-value API
- Synchronous, easy to reason about

Pros:

- Simple
- Works offline
- No backend needed

Cons:

- Limited storage (5-10MB)
- No cross-device sync
- Can be cleared by user

Alternatives:

- IndexedDB (too complex for our needs)
- Backend database (adds complexity, not needed)
```

Then flesh it out with details, examples, and reasoning.

### Write as You Decide, Not After

The best time to write an ADR is **while you're making the decision**, not after implementation.

Why?

- Your reasoning is fresh in your mind
- You remember the alternatives you considered
- You can still articulate the trade-offs clearly

Writing after implementation often results in:

- Incomplete context ("I can't remember what else we considered")
- Rationalization ("We chose X because..." - but did you actually consider alternatives?)
- Missing trade-offs ("We didn't realize Y would be a problem")

In BroteinBuddy, we wrote ADR-001 (Technology Stack Selection) during project setup, before writing application code. This means the ADR accurately reflects our decision-making process, not a post-hoc rationalization.

### Be Honest About Constraints

Sometimes decisions aren't purely technical. Be honest about constraints:

**Budget constraints:**

> "We chose Vercel over AWS because Vercel's free tier is sufficient for our needs, while AWS would require managing infrastructure."

**Time constraints:**

> "We chose LocalStorage over IndexedDB because LocalStorage's synchronous API is simpler to work with, allowing faster development. IndexedDB would be more robust for larger datasets, but our project timeline is short."

**Skill constraints:**

> "We chose Svelte over React Native because I have web development experience but not mobile development experience. Learning React Native would add 2-3 weeks to the timeline."

**Personal project constraints:**

> "This is a portfolio project demonstrating modern web development. We chose Svelte 5 to showcase cutting-edge technology, even though React would be more recognizable to potential employers."

There's no shame in acknowledging real-world constraints. In fact, it makes the ADR more useful because future readers understand the full context.

### Focus on the "Why", Not Just the "What"

Compare these two explanations:

**Bad (What only):**

> "We use TypeScript."

**Good (Why):**

> "We use TypeScript because we want compile-time type checking to catch errors early, improve IDE autocomplete, and make the codebase more maintainable as it grows. The cost is additional build configuration and a learning curve for developers unfamiliar with TypeScript."

The "why" helps future developers understand if the decision still applies to new situations.

### Use Concrete Examples

Abstract reasoning is hard to remember. Concrete examples stick.

**Abstract:**

> "LocalStorage is sufficient for our storage needs."

**Concrete:**

> "We expect to store ~10-50 boxes, each ~100 bytes, plus ~5-10 flavors, each ~50 bytes. Total: ~5-10KB. LocalStorage provides 5-10MB, giving us 1000x headroom. If we ever need to store thousands of boxes, we'd need IndexedDB (documented in ADR-003)."

The concrete example helps future developers make better decisions. When they want to add a feature that stores large images, they'll realize "Oh, we chose LocalStorage for small data, this new feature might need a different approach."

### Cross-Reference Related ADRs

As your project grows, ADRs will reference each other:

```markdown
## Decision

We will use Svelte stores for state management (see ADR-001 for
framework selection). The store will automatically sync to
LocalStorage (see ADR-002 for storage strategy).
```

Or when superseding:

```markdown
# ADR-015: Migrate from LocalStorage to IndexedDB

**Status:** Accepted

**Supersedes:** ADR-002 (LocalStorage Strategy)

## Context

As documented in ADR-002, we chose LocalStorage for simplicity.
However, after six months of usage, we've discovered that power
users are hitting the 5MB storage limit...
```

This creates a narrative arc through your project's evolution.

## Common Pitfalls and How to Avoid Them

### Pitfall 1: Writing ADRs After the Fact

**Problem:** You implement a feature, then try to write an ADR explaining the decision. The ADR becomes a justification rather than a decision record.

**Solution:** Write ADRs during decision-making, before or during early implementation. If you realize you need an ADR after implementation, be honest about it:

> "This ADR documents the technology choices made during initial project setup. While written after implementation began, it captures the reasoning from that time period."

### Pitfall 2: Analysis Paralysis

**Problem:** You spend weeks researching and writing a 20-page ADR comparing every possible option.

**Solution:** ADRs should be lightweight. Spend more time deciding than documenting. A good ADR can be written in 30-60 minutes. If it's taking longer, you might be over-thinking it.

**Rule of thumb:** If the decision took you 2 hours to make, the ADR should take 30-60 minutes to write.

### Pitfall 3: Too Vague or Too Detailed

**Problem:** Either "We chose a modern framework" (too vague) or "Here's a 50-line code example of configuring Vite" (too detailed).

**Solution:** Find the middle ground. Be specific enough that someone can understand and reproduce the decision, but don't include implementation tutorials.

**Good specificity:**

> "We chose Vite with the Svelte plugin. Configuration includes TypeScript support, ESLint integration, and PWA plugin. See `vite.config.ts` for implementation details."

### Pitfall 4: Ignoring Negative Consequences

**Problem:** Only listing positive consequences makes ADRs look like marketing material.

**Solution:** Every decision has trade-offs. Document them honestly. Future developers (including you) need to know what you gave up.

If you genuinely can't think of any negatives, you probably haven't thought hard enough. Even great decisions have constraints or limitations.

### Pitfall 5: Not Maintaining ADR Status

**Problem:** Three years later, you're still using an ADR marked "Proposed" or following an approach that was superseded.

**Solution:** When decisions change, update the ADR status:

```markdown
**Status:** Superseded by ADR-042

---

**UPDATE (2026-05-15):** We have migrated from LocalStorage to
IndexedDB. See ADR-042 for the new approach. This ADR remains for
historical context.
```

Don't delete old ADRs! They're part of your project's history. Just mark them clearly.

### Pitfall 6: Writing for the Wrong Audience

**Problem:** Using jargon or assuming too much context, making ADRs inaccessible to new team members or future you.

**Solution:** Write for someone with general programming knowledge but no context about your project.

**Bad:** "We're using SSR with hydration for performance."

**Good:** "We're using Server-Side Rendering (SSR) where pages are pre-rendered on the server and then 'hydrated' (made interactive) in the browser. This improves initial load time but increases server costs. See ADR-008 for our SSR strategy."

## The Relationship Between ADRs and Other Documentation

ADRs don't replace other documentation - they complement it.

### ADRs + Code Comments

**Code comments** explain implementation details.
**ADRs** explain why we have that implementation.

Example flow:

```typescript
// src/lib/storage.ts

/**
 * Loads application state from LocalStorage.
 * Returns default state if localStorage is empty or corrupted.
 */
export function loadState(): AppState {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) return getDefaultState();

    // Parse and validate with Zod schema (see ADR-002 for storage strategy)
    const parsed = JSON.parse(stored);
    return AppStateSchema.parse(parsed);
  } catch (error) {
    console.warn('Failed to load state, using defaults:', error);
    return getDefaultState();
  }
}
```

The code comment explains what the function does. The ADR reference explains why we chose LocalStorage.

### ADRs + README

**README** is user-facing: how to install, how to use.
**ADRs** are developer-facing: why things work this way.

README might say:

> BroteinBuddy is a Progressive Web App built with Svelte. Works offline and can be installed on iOS.

ADR-001 explains why we chose that stack over alternatives.

### ADRs + DEVELOPING.md

**DEVELOPING.md** explains how to work on the project: setup, testing, deployment.
**ADRs** explain why we have that workflow.

DEVELOPING.md might say:

> Run `npm test` to execute the test suite. We require 90% coverage.

ADR-004 (Testing Strategy) would explain why we chose 90% coverage, why we use Vitest instead of Jest, and what trade-offs that involves.

### ADRs + Architecture Diagrams

**Diagrams** show structure and relationships.
**ADRs** explain why that structure was chosen.

You might have a diagram showing:

```
[Svelte Components] â†’ [Svelte Stores] â†’ [LocalStorage]
```

ADR-001 explains why we chose Svelte, ADR-002 explains LocalStorage, ADR-004 explains the store pattern.

### When to Update Each Document Type

| Situation                          | Update...                             |
| ---------------------------------- | ------------------------------------- |
| Change implementation details      | Code comments, DEVELOPING.md          |
| Change user-facing features        | README, user guide                    |
| Make architectural decision        | Create new ADR                        |
| Change previous decision           | Update old ADR status, create new ADR |
| Refactor without changing approach | Code comments only                    |
| Change tooling/workflow            | DEVELOPING.md, possibly ADR           |
| Discover new trade-off             | Add note to existing ADR              |

## Best Practices for Maintaining ADRs Over Time

### 1. Keep ADRs in Version Control

ADRs should be committed to your git repository, typically in `docs/adr/`.

**Why?**

- Track changes to decisions over time
- See ADRs in their historical context
- Branch-specific decisions can have branch-specific ADRs
- Pull request reviews can include ADR reviews

### 2. Sequential Numbering

Use sequential numbers (001, 002, 003...) not dates or random IDs.

**Why?**

- Creates a chronological narrative
- Easy to reference ("See ADR-042")
- Shows project evolution over time

**Format:**

```
docs/adr/
â”œâ”€â”€ 000-template.md
â”œâ”€â”€ 001-technology-stack-selection.md
â”œâ”€â”€ 002-data-model-design.md
â”œâ”€â”€ 003-localstorage-strategy.md
â””â”€â”€ 004-state-management-approach.md
```

### 3. Create an ADR Index

In your main documentation (DEVELOPING.md or README.md), maintain an index:

```markdown
## Architecture Decision Records

- [ADR-000: Template](docs/adr/000-template.md)
- [ADR-001: Technology Stack Selection](docs/adr/001-technology-stack-selection.md)
- [ADR-002: Data Model Design](docs/adr/002-data-model-design.md) (Proposed)
```

Update this index when creating new ADRs.

### 4. Update Status, Don't Delete

When decisions change, update the status:

```markdown
**Status:** Superseded by ADR-042
```

Or add an update note at the top:

```markdown
---

**UPDATE (2026-03-15):** This decision has been superseded by ADR-042
(Migration to IndexedDB). The LocalStorage approach documented here
was used from 2025-10 to 2026-03. See ADR-042 for current approach.

---
```

**Never delete ADRs.** They're historical records of your project's evolution.

### 5. Review ADRs During Onboarding

When someone joins your project (or when you return after a break), reading ADRs should be part of the onboarding process.

Create a "suggested reading order" in your CONTRIBUTING.md:

```markdown
## Onboarding

To understand this project, read these ADRs in order:

1. ADR-001: Technology Stack Selection - Why Svelte/TypeScript
2. ADR-002: Data Model Design - How we structure data
3. ADR-004: State Management - How we handle application state
4. ADR-007: Testing Strategy - Our testing approach
```

### 6. Reference ADRs in Code Reviews

During code reviews, reference ADRs:

> "This PR uses React instead of Svelte components. Per ADR-001, we chose Svelte for this project because of bundle size and simplicity. If we need to change that decision, we should update ADR-001 or create a new ADR explaining why."

### 7. Revisit ADRs When Assumptions Change

If a major assumption changes (new browser capabilities, library deprecated, business requirements shift), review related ADRs:

```markdown
**Status:** Under Review (2026-06-01)

**Note:** Service Worker APIs have improved significantly since this
decision. We're reconsidering the PWA strategy. Discussion in issue #342.
```

### 8. Use ADRs to Prevent Bikeshedding

When debates arise ("Should we refactor to use X?"), check if there's an ADR:

> "We discussed this in ADR-015 and decided against X because Y. Has something changed that makes us reconsider? If so, let's document the new context in a new ADR."

This prevents repeatedly debating the same topics.

## Real-World Example: ADR-001 Walkthrough

Let's analyze what makes ADR-001 (Technology Stack Selection) effective:

### It's Comprehensive But Concise

The ADR covers five alternatives without being overwhelming. Each alternative gets enough detail to understand the trade-offs, but not so much that it becomes a tutorial.

### It's Honest About Trade-offs

Notice the Negative consequences:

- Svelte has a smaller ecosystem
- LocalStorage has storage limits
- No backend means no server-side features

We didn't pretend our choices were perfect. We acknowledged the limitations.

### It Provides Concrete Reasons

Instead of "Svelte is better," we said:

- Minimal boilerplate
- Smaller bundle sizes than React/Vue
- Excellent performance

These are specific, measurable benefits.

### It Explains Why We Rejected Alternatives

For each alternative, we didn't just say "We didn't choose this." We explained:

- React: "More boilerplate than we need for this project"
- IndexedDB: "Overkill for our simple key-value needs"
- Backend: "Adds unnecessary complexity for single-user app"

This prevents future "Why didn't we just..." questions.

### It Includes References

Links to Svelte docs, Vite docs, PWA best practices, etc. provide jumping-off points for deeper learning.

### It's Timestamped

The date (2025-10-25) provides context. Technology evolves. What made sense in 2025 might not make sense in 2028. The date helps readers understand the decision in historical context.

## What You Should Learn From This

### Key Takeaways

1. **ADRs are time machines** - They let you revisit past thinking and understand why decisions were made.

2. **Write during decision-making** - Not after implementation. The best ADRs capture reasoning while it's fresh.

3. **Be honest about trade-offs** - Every decision has costs. Document them honestly.

4. **Consider alternatives explicitly** - Don't just pick the first option. Evaluate alternatives and document why you rejected them.

5. **ADRs complement other docs** - They focus on "why" while other docs cover "what" and "how".

6. **Maintain them over time** - Update status when decisions change. Never delete ADRs.

7. **Use them as conversation starters** - When debates arise, check for existing ADRs or create new ones.

### Patterns to Remember

**The "No Backend" Pattern:**
Sometimes constraints (like "no backend") immediately narrow your options. Document these constraints clearly in the Context section.

**The "Portfolio Project" Pattern:**
Personal projects have different constraints than enterprise projects. Be explicit about this in your ADRs.

**The "Current State of Technology" Pattern:**
Technology evolves. What's cutting-edge today might be standard tomorrow. Include dates and references to capture the state of technology when you decided.

**The "Learning Curve" Pattern:**
Time and skill constraints are valid decision factors. Be honest about them.

### When to Break the Rules

Like all documentation practices, ADRs have diminishing returns. Don't write ADRs for:

- Trivial decisions (variable naming, single function implementation)
- Obvious choices (using git for version control)
- Decisions that don't affect architecture
- Temporary experiments or prototypes

Use your judgment. If you find yourself thinking "I should document why I made this choice," that's a sign you need an ADR.

## Going Deeper

### Books and Articles

- **"Documenting Architecture Decisions" by Michael Nygard** (2011)
  - Original blog post introducing ADRs
  - [https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions](https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions)

- **"Architecture Decision Records in Action" by Joel Parker Henderson**
  - Practical guide with examples
  - [https://github.com/joelparkerhenderson/architecture-decision-record](https://github.com/joelparkerhenderson/architecture-decision-record)

- **"Sustainable Web Development with Ruby on Rails" by David Heinemeier Hansson**
  - Chapter on documentation includes ADR best practices

### Tools and Templates

- **ADR Tools:**
  - [adr-tools](https://github.com/npryce/adr-tools) - CLI for managing ADRs
  - [log4brains](https://github.com/thomvaill/log4brains) - ADR management with web UI

- **Alternative Templates:**
  - [MADR](https://adr.github.io/madr/) - Markdown ADR format
  - [Alexandrian Pattern](https://github.com/joelparkerhenderson/architecture-decision-record#alexandrian-pattern) - More structured format

- **Examples in the Wild:**
  - [Spotify ADRs](https://github.com/spotify/web-api/tree/master/adrs) (if publicly available)
  - Search GitHub for "docs/adr" to find real-world examples

### Related Concepts

- **Design Documents (Design Docs):** More detailed than ADRs, often include implementation plans
- **Request for Comments (RFCs):** Used in open-source for proposing changes
- **Postmortems:** Documenting what went wrong after incidents (ADRs document decisions, postmortems document outcomes)
- **Technical Debt Registers:** Track known issues and tech debt (different focus from ADRs)

## Questions to Think About

1. **How do you decide if a decision is "architecturally significant" enough for an ADR?**
   - Consider: Would this be expensive to reverse? Will it affect multiple components? Will future developers wonder why you chose this approach?

2. **What if your team disagrees on a decision?**
   - Document the disagreement in the ADR. List the different viewpoints in the Alternatives section. Explain why the chosen approach won out.

3. **Should you write ADRs for decisions you regret?**
   - Absolutely! These are often the most valuable. Mark them as "Superseded" and write a new ADR explaining what you learned.

4. **How detailed should the Alternatives section be?**
   - Enough that someone can understand why you rejected each alternative without needing to research them from scratch. Usually 2-3 paragraphs per alternative.

5. **What if you're working alone and feel like ADRs are overkill?**
   - Try writing just one ADR for your most important decision. Six months later, revisit it. Did it help you remember your reasoning? That's your answer.

6. **How do you balance ADR completeness with moving fast?**
   - Set a time limit. 30-60 minutes per ADR. If you're spending longer, you're overthinking it. You can always add details later if needed.

7. **Should you write ADRs in Markdown, or use a specialized tool?**
   - Markdown in git is the most portable and future-proof option. Specialized tools can help with organization but add dependency risk.

## Conclusion

Architecture Decision Records are a lightweight, powerful tool for preserving institutional memory. By documenting not just what you decided, but why you decided it and what else you considered, you create a knowledge base that helps future developers (including future you) understand your project's evolution.

Start small. Write one ADR for your next significant decision. See if it helps. Then write another. Over time, you'll build a valuable archive that makes onboarding faster, prevents repeated debates, and helps everyone understand why the codebase looks the way it does.

Remember: The goal isn't perfection. The goal is to capture enough context that six months from now, you can read the ADR and think "Ah yes, that's why we did it that way" instead of "What was I thinking?"

Welcome to the world of thoughtful, documented decision-making. Your future self thanks you.
