# Svelte 5 Patterns: Runes, Reactivity, and State Management

This document explores the Svelte 5 patterns used in the Random Selection Flow, explaining the new runes system, when to use each pattern, and how to think about reactivity in modern Svelte applications.

## Context: Svelte 4 vs Svelte 5

Svelte 5 introduces **runes** - a new way to express reactivity that's more explicit and predictable than Svelte 4's "magic" reactivity.

### Svelte 4 Approach (Implicit Reactivity)

```svelte
<script>
  // Automatically reactive (Svelte makes this magic)
  let count = 0;

  // Reactive statement
  $: doubled = count * 2;

  // Reactive block
  $: {
    console.log('Count changed:', count);
  }

  // Store subscription (also magic)
  import { appState } from './stores';
  // $appState is automatically unwrapped
</script>
```

**Problems with Svelte 4:**

- Hard to tell what's reactive and what isn't
- `$:` syntax is confusing for beginners
- Difficult to compose reactive logic
- No clear separation between state and effects

### Svelte 5 Approach (Explicit Reactivity)

```svelte
<script lang="ts">
  // Explicit reactive state
  let count = $state(0);

  // Explicit derived state
  let doubled = $derived(count * 2);

  // Explicit effect
  $effect(() => {
    console.log('Count changed:', count);
  });

  // Store subscription (still uses $ but more consistent)
  import { appState } from './stores';
  // $appState is explicitly a store subscription
</script>
```

**Benefits of Svelte 5:**

- Clear intent: `$state` means "this can change"
- Predictable: `$derived` means "this is computed from other reactive values"
- Composable: Easier to extract logic into functions
- Familiar: Similar to React hooks, Vue composition API

Let's explore each rune used in the Random Selection Flow.

---

## Rune #1: `$state` - Reactive Local State

### What It Does

Creates reactive state that triggers component re-renders when changed.

### Basic Usage

```typescript
let count = $state(0);
let name = $state('Alice');
let isOpen = $state(false);
```

When you update the value, Svelte automatically re-renders:

```typescript
count = count + 1; // Component re-renders
name = 'Bob'; // Component re-renders
isOpen = !isOpen; // Component re-renders
```

### From Random.svelte

```typescript
let isSelecting = $state(false);
let errorMessage: string | null = $state(null);
```

**Why `$state`?**

- `isSelecting` controls whether we show the spinner or error message
- `errorMessage` stores the current error (or null if no error)
- Both affect what's rendered, so they need to trigger re-renders

### With TypeScript Types

```typescript
let selectedFlavor = $state<Flavor | null>(null);
let priorityBox = $state<Box | null>(null);
let alternativeBoxes = $state<Box[]>([]);
```

**Why type annotations?**

TypeScript can't always infer the type from the initial value. When you initialize with `null`, TypeScript thinks the type is `null`, not `Flavor | null`. The type annotation fixes this.

### State Updating Patterns

**Direct assignment:**

```typescript
errorMessage = 'Something went wrong';
isSelecting = false;
```

**Conditional updates:**

```typescript
if (flavor === null) {
  errorMessage = determineErrorMessage();
  isSelecting = false;
}
```

**From async operations:**

```typescript
onMount(() => {
  setTimeout(() => {
    performSelection(); // This updates state inside
  }, 10);
});
```

### When to Use `$state`

Use `$state` when:

- ✅ The value changes over time
- ✅ Changes should trigger re-renders
- ✅ The state is local to this component

Don't use `$state` when:

- ❌ The value never changes (use regular `const`)
- ❌ The value is derived from other state (use `$derived`)
- ❌ The state is shared across components (use stores)

---

## Rune #2: `$derived` - Computed State

### What It Does

Creates state that's automatically computed from other reactive values. Re-computes when dependencies change.

### Basic Usage

```typescript
let count = $state(0);
let doubled = $derived(count * 2);

// When count changes, doubled updates automatically
count = 5; // doubled is now 10
```

### From Random.svelte: Query Parameter Parsing

```typescript
let excludeLastPick = $derived.by(() => {
  const params = new URLSearchParams($location.split('?')[1] || '');
  return params.get('excludeLastPick') || undefined;
});
```

**Why `$derived.by()` instead of `$derived`?**

Two flavors:

- `$derived(expression)` - For simple expressions
- `$derived.by(() => { ... })` - For complex logic requiring a function body

**Simple `$derived`:**

```typescript
let doubled = $derived(count * 2);
let fullName = $derived(`${firstName} ${lastName}`);
```

**Complex `$derived.by()`:**

```typescript
let excludeLastPick = $derived.by(() => {
  // Multi-step logic
  const queryString = $location.split('?')[1] || '';
  const params = new URLSearchParams(queryString);
  const value = params.get('excludeLastPick');
  return value || undefined;
});
```

### Reactivity: How It Works

The `$derived.by()` automatically tracks dependencies:

```typescript
let excludeLastPick = $derived.by(() => {
  // This reads $location, so it's a dependency
  const params = new URLSearchParams($location.split('?')[1] || '');
  return params.get('excludeLastPick') || undefined;
});
```

When `$location` changes (from navigation), `excludeLastPick` re-computes automatically.

**Example flow:**

1. User at `/random` → `excludeLastPick` is `undefined`
2. User clicks "Different Choice" → Navigate to `/random?excludeLastPick=chocolate`
3. `$location` changes → `excludeLastPick` re-computes → Now `'chocolate'`
4. `performSelection()` uses the new value → Excludes chocolate from selection

### When to Use `$derived`

Use `$derived` when:

- ✅ The value is computed from other reactive values
- ✅ It should update automatically when dependencies change
- ✅ No side effects (pure computation)

Don't use `$derived` when:

- ❌ The value is independent (use `$state`)
- ❌ You need side effects (use `$effect`)
- ❌ The computation is expensive and doesn't need to update immediately (use `$state` with manual updates)

---

## Rune #3: `$effect` - Side Effects

### What It Does

Runs code when reactive dependencies change. Used for side effects (logging, API calls, localStorage updates, etc.).

### Basic Usage

```typescript
let count = $state(0);

$effect(() => {
  console.log('Count is now:', count);
  // Runs whenever count changes
});
```

### From stores.ts (Auto-Save Pattern)

```typescript
// In stores.ts
export const appState = writable<AppState>(loadState());

// Auto-save to localStorage whenever state changes
$effect(() => {
  saveState($appState);
});
```

**How it works:**

1. `appState` is a writable store
2. `$effect` subscribes to `appState` (via `$appState`)
3. Whenever `appState` changes, the effect runs
4. `saveState()` writes the current state to localStorage

**Why this is powerful:**

Every state update automatically persists:

```typescript
updateBoxQuantity('box-1', 5); // State changes → Effect runs → Saved to localStorage
```

No need to manually call `saveState()` everywhere. It's automatic.

### Effect Cleanup

Effects can return a cleanup function:

```typescript
$effect(() => {
  const interval = setInterval(() => {
    console.log('Tick');
  }, 1000);

  // Cleanup when component unmounts or effect re-runs
  return () => clearInterval(interval);
});
```

### Effect Dependencies

Effects automatically track dependencies:

```typescript
let count = $state(0);
let name = $state('Alice');

$effect(() => {
  console.log('Count changed:', count);
  // Only re-runs when count changes (not when name changes)
});

$effect(() => {
  console.log('Name or count:', name, count);
  // Re-runs when either name or count changes
});
```

Svelte tracks which reactive values are read inside the effect and re-runs only when those change.

### When to Use `$effect`

Use `$effect` when:

- ✅ You need side effects (logging, API calls, DOM manipulation)
- ✅ The effect should run when reactive values change
- ✅ You need cleanup (subscriptions, timers, event listeners)

Don't use `$effect` when:

- ❌ You're computing a value (use `$derived`)
- ❌ You're updating state based on other state (use `$derived`)
- ❌ The side effect should only run once (use `onMount`)

---

## Pattern: Store Subscriptions with `$` Prefix

### What It Does

Auto-subscribes to Svelte stores and unwraps their value.

### From Random.svelte

```typescript
import { appState } from '$lib/stores';

// Access the current state value
const flavor = selectRandomFlavor($appState, excludeLastPick);
```

**Under the hood:**

```typescript
// $appState is shorthand for:
let appStateValue;
const unsubscribe = appState.subscribe((value) => {
  appStateValue = value;
});

// Then in onDestroy:
onDestroy(() => unsubscribe());
```

Svelte handles the subscription and cleanup automatically.

### Reactivity with Stores

When the store updates, components that use `$appState` re-render:

```typescript
// In component A
console.log($appState.boxes); // [box1, box2]

// In component B
updateBoxQuantity('box1', 10); // Modifies store

// Component A automatically re-renders with new value
console.log($appState.boxes); // [box1 (updated), box2]
```

### Derived Values from Stores

You can derive from store values:

```typescript
let boxCount = $derived($appState.boxes.length);
let flavorNames = $derived($appState.flavors.map((f) => f.name));
```

**Reactivity chain:**

1. Store updates → `$appState` changes
2. `$appState` changes → Derived values re-compute
3. Derived values change → Component re-renders

### When to Use Stores vs `$state`

**Use stores when:**

- State is shared across multiple components
- State needs to persist (auto-save to localStorage)
- Multiple components need to update the same state

**Use `$state` when:**

- State is local to one component
- State is temporary (like UI state)
- No other components need access

---

## Architecture: State Flow Between Screens

Let's trace the complete state flow for the Random Selection feature.

### Flow Diagram

```
Home Screen
    |
    | User taps "Random"
    v
Random.svelte
    |
    | onMount: performSelection()
    |
    | selectRandomFlavor($appState, excludeLastPick)
    |     - Reads from appState store
    |     - Performs weighted random selection
    |     - Returns Flavor | null
    |
    +---> If null: Show error message (state: errorMessage)
    |
    +---> If Flavor:
          - sessionStorage.setItem('selectedFlavorId', flavor.id)
          - navigate to /random/confirm
          |
          v
RandomConfirm.svelte
    |
    | onMount: Load from sessionStorage
    |     - sessionStorage.getItem('selectedFlavorId')
    |     - maybeGetFlavor(flavorId, $appState.flavors)
    |     - selectPriorityBox($appState.boxes, flavorId)
    |
    | Display: selectedFlavor, priorityBox, alternativeBoxes
    |
    | User actions:
    |
    +---> Confirm:
    |       - updateBoxQuantity(id, qty - 1)  [Updates store]
    |       - sessionStorage.removeItem('selectedFlavorId')
    |       - navigate to /
    |
    +---> Add Another:
    |       - updateBoxQuantity(id, qty - 1)  [Updates store]
    |       - refreshBoxSelection()  [Re-reads from store]
    |       - Stay on screen
    |
    +---> Different Choice:
    |       - sessionStorage.removeItem('selectedFlavorId')
    |       - navigate to /random?excludeLastPick=<flavorId>
    |       - [Loops back to Random.svelte]
    |
    +---> Cancel:
          - sessionStorage.removeItem('selectedFlavorId')
          - navigate to /
```

### State Layers

This architecture uses **three layers of state**:

#### Layer 1: Global Persistent State (Svelte Stores)

```typescript
export const appState = writable<AppState>(loadState());
```

- **Scope**: Entire application
- **Lifetime**: Persists in localStorage
- **Use cases**: Boxes, flavors, inventory data

#### Layer 2: Workflow State (sessionStorage)

```typescript
sessionStorage.setItem('selectedFlavorId', flavor.id);
```

- **Scope**: Current workflow (random selection)
- **Lifetime**: Until workflow completes or tab closes
- **Use cases**: Selected flavor ID between screens

#### Layer 3: Component State (Svelte Runes)

```typescript
let isSelecting = $state(false);
let errorMessage = $state<string | null>(null);
```

- **Scope**: Single component
- **Lifetime**: While component is mounted
- **Use cases**: UI state, loading states, error messages

### Why Three Layers?

**Why not put everything in stores?**

Stores are great for shared state, but overkill for temporary UI state. Do we really need a global store for "is the spinner showing"? No.

**Why not put everything in component state?**

Component state doesn't survive navigation. If we stored `selectedFlavorId` in `$state`, it would be lost when navigating from Random → RandomConfirm.

**Why not put everything in sessionStorage?**

sessionStorage is synchronous and doesn't trigger reactivity. We'd need to manually check for updates.

**The sweet spot:** Each layer handles what it's good at:

- Stores: Shared, persistent data
- sessionStorage: Workflow state across navigation
- Component state: Local UI state

---

## Advanced Pattern: Conditional Reactivity

### The Problem

Sometimes you want reactivity that only fires under certain conditions.

### Example: Refresh Box Selection

```typescript
function refreshBoxSelection() {
  if (!selectedFlavorId) return; // Guard clause

  priorityBox = selectPriorityBox($appState.boxes, selectedFlavorId);

  if (!priorityBox) {
    errorMessage = 'No boxes available for this flavor.';
    return;
  }

  const allFlavorBoxes = $appState.boxes
    .filter((b) => b.flavorId === selectedFlavorId && b.id !== priorityBox?.id)
    .sort(compareBoxPriority);

  alternativeBoxes = allFlavorBoxes;
  errorMessage = null;
}
```

**Why not use `$derived`?**

This could be derived:

```typescript
let priorityBox = $derived(
  selectedFlavorId ? selectPriorityBox($appState.boxes, selectedFlavorId) : null
);
```

**But:**

- We need the error message side effect
- We need the alternative boxes computation
- We want manual control over when it updates (only after "Add Another")

**Pattern:** Use a function that reads reactive values but isn't itself reactive. Call it manually when needed.

### When to Choose Manual Functions

Use manual functions when:

- ✅ You need side effects (setting multiple state variables)
- ✅ You want control over when updates happen
- ✅ The computation is expensive and shouldn't run on every state change

Use `$derived` when:

- ✅ Pure computation, no side effects
- ✅ Should update automatically on every dependency change
- ✅ The computation is cheap

---

## Pattern: Defensive State Access

### The Problem

State might not be loaded yet when components mount.

### Example: Loading Flavor from sessionStorage

```typescript
onMount(() => {
  const flavorId = sessionStorage.getItem('selectedFlavorId');

  if (!flavorId) {
    errorMessage = 'No flavor selected. Please start from the Random Selection screen.';
    return;
  }

  selectedFlavorId = flavorId;
  selectedFlavor = maybeGetFlavor(flavorId, $appState.flavors);

  if (!selectedFlavor) {
    errorMessage = 'Selected flavor not found. It may have been deleted.';
    return;
  }

  refreshBoxSelection();
});
```

**Defensive checks:**

1. Check if sessionStorage has the value
2. Check if the flavor still exists
3. Only proceed if both checks pass

**Why this matters:**

Users do unexpected things:

- Navigate directly to `/random/confirm` without going through `/random`
- Delete a flavor while on the confirmation screen (in another tab)
- Bookmark URLs and revisit later

Defensive programming prevents crashes.

### Pattern: Early Returns

```typescript
if (!condition) {
  errorMessage = 'Helpful error message';
  return; // Stop here
}

// Continue with happy path
```

This is clearer than nested if-else:

```typescript
// Avoid deep nesting
if (condition) {
  if (otherCondition) {
    if (anotherCondition) {
      // Happy path buried deep
    }
  }
}
```

**Early returns flatten the logic** and make the happy path obvious.

---

## Pattern: Auto-Save with Effects

### The Implementation (stores.ts)

```typescript
export const appState = writable<AppState>(loadState());

// Auto-save effect
$effect(() => {
  saveState($appState);
});
```

**How it works:**

1. Store is created, initialized with `loadState()` (reads from localStorage)
2. Effect subscribes to store
3. Whenever store changes, effect runs
4. Effect calls `saveState($appState)` to persist

**Why this is elegant:**

No manual save calls needed:

```typescript
// Before (manual saves everywhere)
function updateBoxQuantity(id: string, qty: number) {
  // Update state
  appState.update((state) => {
    const box = state.boxes.find((b) => b.id === id);
    if (box) box.quantity = qty;
    return state;
  });

  // Manual save (easy to forget!)
  saveState(get(appState));
}

// After (auto-save)
function updateBoxQuantity(id: string, qty: number) {
  appState.update((state) => {
    const box = state.boxes.find((b) => b.id === id);
    if (box) box.quantity = qty;
    return state;
  });
  // Save happens automatically!
}
```

### Trade-offs

**Pros:**

- ✅ Can't forget to save
- ✅ Consistent across all updates
- ✅ Single source of truth

**Cons:**

- ❌ Saves on every update (could be expensive for large state)
- ❌ No batching (multiple updates = multiple saves)

**Optimization (if needed):**

Debounce the saves:

```typescript
let saveTimeout;

$effect(() => {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    saveState($appState);
  }, 100); // Save 100ms after last change
});
```

But for BroteinBuddy's small state, immediate saves are fine.

---

## Questions to Think About

1. **When would you use `$state` vs `$derived`?**
   - Hint: Is the value independent or computed?

2. **How does `$derived.by()` track dependencies?**
   - Hint: It reads reactive values inside the function

3. **Why use sessionStorage instead of a Svelte store** for workflow state?
   - Hint: What happens to stores when you navigate?

4. **What's the difference between `$effect` and `onMount`?**
   - Hint: When do they run? How many times?

5. **How would you implement undo/redo** with Svelte 5 runes?
   - Hint: Think about a history array and derived current state

---

## Summary: Svelte 5 Mental Model

### Think in Layers

1. **`$state`**: "This value can change"
2. **`$derived`**: "This value is computed from other values"
3. **`$effect`**: "Do something when values change"
4. **Stores**: "Share this state across components"

### Reactivity Rules

1. Reading a reactive value inside `$derived` or `$effect` creates a dependency
2. Updating a reactive value triggers re-renders and dependent effects
3. Effects run after the component renders (not during)

### Best Practices

1. **Minimize state**: Derive what you can, store what you must
2. **Defensive coding**: Check for null/undefined, provide error messages
3. **Separation of concerns**: UI state in components, data state in stores
4. **Document non-obvious choices**: Why sessionStorage? Why this timing?

---

## Going Deeper

Want to learn more about Svelte 5 runes?

- **Official Docs**: https://svelte-5-preview.vercel.app/docs/runes
- **Svelte 5 Migration Guide**: https://svelte-5-preview.vercel.app/docs/breaking-changes
- **Rich Harris on Runes**: https://www.youtube.com/watch?v=RVnxF3j3N8U

---

## Conclusion

Svelte 5's runes system makes reactivity explicit and predictable. Instead of magic `$:` statements, you clearly declare:

- "This is state" (`$state`)
- "This is derived" (`$derived`)
- "This has side effects" (`$effect`)

The Random Selection Flow demonstrates these patterns in a real-world feature: local state for UI, derived state for query params, effects for auto-save, and stores for shared data.

Understanding these patterns will help you build Svelte 5 applications that are reactive, maintainable, and performant.
