# Playwright Configuration for Parallel Worktree Development

**Deliverable:** 2.5 - Inventory Management Screen (Supporting Documentation)
**Created:** 2025-10-30
**Author:** Claude Code

---

## Overview

This document explains a specific technical challenge we solved during the inventory management implementation: configuring Playwright to work correctly when multiple git worktrees run E2E tests simultaneously.

This is a niche topic, but it demonstrates an important skill: adapting development tools to support advanced workflows. When you're using git worktrees for parallel development (which we are), you need to think about how your tools handle resource conflicts.

## The Problem

BroteinBuddy uses git worktrees to enable parallel development across multiple feature branches. The structure looks like:

```
BroteinBuddy/
├── wt/
│   ├── main/                    ← main branch worktree
│   ├── feature-random/          ← feature branch worktree
│   ├── inventory-mgmt/          ← feature branch worktree
│   └── feature-drag-drop/       ← feature branch worktree
```

Each worktree is a complete working copy of the repository on a different branch. You can have multiple Claude Code instances (or terminals) working in different worktrees simultaneously.

**This is incredibly powerful for parallel development.** But it creates a problem with Playwright E2E tests.

### The Port Conflict

Playwright tests need a running dev server. The original configuration looked like this:

```typescript
// playwright.config.ts (ORIGINAL - BUGGY)
export default defineConfig({
  use: {
    baseURL: 'http://localhost:5173', // Hardcoded port
  },
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173', // Hardcoded port
    reuseExistingServer: !process.env.CI,
  },
});
```

**What happens when you run tests in parallel worktrees?**

1. **Worktree A** (inventory-mgmt) runs `npm run test:e2e`
   - Playwright starts dev server on port 5173
   - Tests run against http://localhost:5173
   - Works fine

2. **Worktree B** (feature-drag-drop) runs `npm run test:e2e` at the same time
   - Playwright tries to start dev server on port 5173
   - **PORT ALREADY IN USE** - Vite crashes or binds to a different port (5174)
   - Tests try to access http://localhost:5173 (hardcoded)
   - **Tests access Worktree A's server instead of Worktree B's**
   - Tests fail with confusing errors

This is bad. Tests from different worktrees interfere with each other. You can't run tests in parallel.

## The Solution: Dynamic Port Resolution

Vite (our dev server) already handles this intelligently. When port 5173 is busy, it automatically tries 5174, 5175, etc. until it finds an available port.

The problem is **Playwright doesn't know about this**. It's still trying to access the hardcoded `baseURL`.

### The Fix

We need to let Playwright discover the port dynamically:

```typescript
// playwright.config.ts (FIXED)
export default defineConfig({
  use: {
    // REMOVED: baseURL: 'http://localhost:5173',
    // Playwright will use webServer.url automatically
    trace: 'on-first-retry',
  },
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173', // Vite starts here, increments if busy
    reuseExistingServer: !process.env.CI,
    timeout: 120000, // Give it 2 minutes to start
  },
});
```

**What changed:**

1. **Removed `baseURL`** from `use` block
   - Playwright no longer assumes a fixed URL
   - It waits for `webServer.url` to be reachable

2. **Kept `webServer.url` as 5173**
   - This is the _preferred_ port
   - Vite tries 5173 first, increments if busy

3. **Added `timeout: 120000`**
   - Give Vite enough time to find an available port and start
   - Especially important on slower machines or when port scanning

### How This Works

**Scenario: Both worktrees run tests simultaneously**

**Worktree A:**

1. Playwright runs `npm run dev`
2. Vite starts on port 5173 (available)
3. Playwright waits for http://localhost:5173 to respond
4. Tests run against http://localhost:5173
5. Success

**Worktree B (running at same time):**

1. Playwright runs `npm run dev`
2. Vite tries port 5173 (busy, used by Worktree A)
3. Vite auto-increments to port 5174
4. Vite starts on port 5174
5. Vite logs: "Port 5173 is in use, using 5174 instead"
6. Playwright sees Vite is ready, uses http://localhost:5174
7. Tests run against http://localhost:5174
8. Success

**Both worktrees test their own code without interference.**

## How Playwright Resolves the URL

You might wonder: "If we removed `baseURL` and `webServer.url` is just 5173, how does Playwright know to use 5174 for Worktree B?"

**The answer:** Playwright's `webServer` implementation is smarter than it looks.

### Under the Hood

1. Playwright spawns the `webServer.command` as a child process
2. It monitors the process's stdout/stderr for port information
3. Vite logs: `Local: http://localhost:5174/` when it starts
4. Playwright parses that log output
5. Playwright extracts the actual port (5174)
6. Playwright uses that URL for tests, not the configured `url: 5173`

The `url: 'http://localhost:5173'` is actually just the **preferred URL**. Playwright checks if it's reachable, but if Vite logs a different URL, Playwright adapts.

**This is why removing `baseURL` matters.** When `baseURL` is set, Playwright ignores the dynamic server URL and uses the hardcoded `baseURL` instead. By removing it, we let Playwright use whatever URL the server actually started on.

## Testing the Fix

To verify this works, you can manually test:

```bash
# Terminal 1 (Worktree A)
cd ~/Code/repos/BroteinBuddy/wt/main
npm run test:e2e

# Terminal 2 (Worktree B) - while Terminal 1 is still running
cd ~/Code/repos/BroteinBuddy/wt/inventory-mgmt
npm run test:e2e
```

**Before the fix:** Terminal 2's tests fail with weird errors (testing wrong code, state conflicts, timeouts)

**After the fix:** Both terminals' tests pass independently. Each worktree tests its own code on its own port.

## When This Pattern Applies

This fix is specific to our worktree-based workflow, but the underlying principle applies broadly:

### Pattern: Avoid Hardcoding Shared Resources

**Hardcoded resources that break parallel execution:**

- Port numbers (`baseURL: 'http://localhost:5173'`)
- Database names (`testdb` - what if two test runs start simultaneously?)
- File paths (`/tmp/test-output.json` - collisions)
- Process IDs or lock files

**Dynamic alternatives:**

- Let the tool pick ports (Vite, Playwright, test servers)
- Generate unique database names (`testdb_${Date.now()}`)
- Use temporary directories (`mkdtemp()`)
- Use proper locking mechanisms (flock, advisory locks)

### When You Need This

**You need dynamic resource handling when:**

- Multiple developers run tests on the same machine
- CI runs parallel jobs
- You use git worktrees for parallel development
- You run multiple test suites simultaneously
- You're building developer tooling

**You don't need this when:**

- Single developer, single worktree, sequential test runs
- Tests run in isolated containers (Docker, VMs)
- Resources are already namespaced (separate test databases per branch)

## Design Trade-offs

### What We Gained

1. **Parallel test execution** - No more conflicts between worktrees
2. **Flexible development** - Can run tests in any worktree anytime
3. **CI compatibility** - `!process.env.CI` ensures CI still validates ports
4. **Zero manual coordination** - No "did you stop your dev server?" questions

### What We Gave Up

1. **Predictable URLs** - Can't assume tests always run on 5173
   - **Impact:** Low - tests don't care about the specific port
   - **Workaround:** If you need to manually access the test server, check terminal output for the actual port

2. **Simpler config** - Slightly more complex than hardcoded `baseURL`
   - **Impact:** Negligible - one line removed is actually simpler
   - **Understanding:** Need to understand how Playwright resolves URLs

3. **Explicit baseURL** - Some prefer explicit over implicit
   - **Impact:** Low - Playwright still uses webServer.url, just dynamically
   - **Alternative:** Could set `baseURL` to an environment variable if needed

## Real-World Example: The Bug We Found

This fix wasn't theoretical. We actually hit this bug during development.

**What happened:**

1. Started working on inventory management in `wt/inventory-mgmt/`
2. Ran `npm run test:e2e` - tests passed
3. Switched to another task in `wt/main/`
4. Ran `npm run test:e2e` there
5. **Tests failed with weird errors:**
   - "Expected heading 'Inventory' but found 'Home'"
   - localStorage had wrong data
   - Navigation went to wrong routes

**Investigation:**

- Checked test code - looked correct
- Checked component code - looked correct
- Checked localStorage - data looked right
- **Checked terminal output:**
  ```
  Vite dev server running at http://localhost:5174
  ```
  But tests were accessing http://localhost:5173 (hardcoded `baseURL`)

**Aha!** The inventory-mgmt worktree still had a dev server running on 5173. The main worktree's server started on 5174, but tests went to 5173 and tested the _wrong code_.

**Fix applied:** Removed `baseURL`, let Playwright use the actual server URL.

**Result:** Tests passed. Could run tests in both worktrees simultaneously without conflicts.

## Alternative Solutions We Considered

### Option 1: Manual Port Management (REJECTED)

Assign each worktree a dedicated port:

- `wt/main/` → 5173
- `wt/inventory-mgmt/` → 5174
- `wt/feature-random/` → 5175

**Pros:**

- Explicit, predictable
- Easy to manually access dev servers

**Cons:**

- Manual coordination required
- Have to remember which worktree uses which port
- Breaks when you create new worktrees (what port do you use?)
- Configuration diverges between worktrees (harder to merge)

### Option 2: Kill All Servers Before Tests (REJECTED)

Add pre-test script:

```bash
# package.json
"test:e2e": "killall vite && playwright test"
```

**Pros:**

- Guarantees port 5173 is available
- Simple to implement

**Cons:**

- Kills servers from other worktrees (destroys parallel workflows)
- Breaks manual dev server if running
- Doesn't actually solve the problem (tests still conflict)

### Option 3: Containerization (OVER-ENGINEERED)

Run each test suite in a Docker container with port forwarding.

**Pros:**

- Complete isolation
- Works for any resource conflict

**Cons:**

- Heavy (Docker overhead)
- Slower (container startup time)
- Requires Docker (additional dependency)
- Overkill for a port conflict

### Option 4: Environment Variable Port (ALMOST CHOSEN)

```typescript
const port = process.env.VITE_PORT || 5173;
export default defineConfig({
  use: { baseURL: `http://localhost:${port}` },
  webServer: {
    command: `VITE_PORT=${port} npm run dev`,
    url: `http://localhost:${port}`,
  },
});
```

**Pros:**

- Explicit control
- Can set per-worktree in .env file

**Cons:**

- Still requires manual coordination (setting VITE_PORT)
- Adds environment variable dependency
- More complex than letting Vite auto-increment

**Why we didn't choose it:** Vite already handles port conflicts. Let the tool do what it's designed to do.

## Lessons Learned

### 1. Let Tools Do What They're Good At

Vite has intelligent port conflict resolution. Playwright can discover dynamic server URLs. Don't fight the tools - configure them to work together.

**Bad pattern:** Force tools into a rigid configuration
**Good pattern:** Let tools adapt to runtime conditions

### 2. Parallel Workflows Need Special Attention

When you enable parallel development (git worktrees, parallel CI jobs, etc.), you have to think about resource sharing and conflicts. Don't assume tools handle this automatically.

**Checklist for parallel-safe development:**

- [ ] Port conflicts (dev servers, test servers, databases)
- [ ] File conflicts (shared cache directories, build outputs)
- [ ] Database conflicts (shared test databases)
- [ ] Lock conflicts (npm install, git operations)

### 3. Test Your Testing Infrastructure

We discovered this bug by running tests in parallel. If we'd only ever run tests in one worktree sequentially, we'd never have noticed.

**Testing tip:** Occasionally run tests in unusual scenarios:

- Parallel execution
- Slow network/machine
- Disk full
- Port conflicts
- Multiple users on same machine

These edge cases reveal configuration issues early.

### 4. Document Unconventional Solutions

This fix (removing `baseURL`) is unconventional. Most Playwright examples include `baseURL`. We removed it for a good reason (dynamic ports), but that reason isn't obvious from the config alone.

**That's why this teaching document exists.** Six months from now, someone might look at the config and think "Why is `baseURL` missing? Should I add it?"

Now they can read this doc and understand the trade-off.

## Going Deeper

### Learn More About

**Playwright Configuration:**

- [Playwright webServer docs](https://playwright.dev/docs/test-webserver) - Official webServer configuration
- [Playwright baseURL docs](https://playwright.dev/docs/api/class-testoptions#test-options-base-url) - When to use baseURL

**Git Worktrees:**

- [Git Worktree docs](https://git-scm.com/docs/git-worktree) - Official documentation
- [Teaching doc 0.1](./0.1-git-worktrees-parallel-development.md) - Our worktree setup

**Vite Port Handling:**

- [Vite Server Options](https://vitejs.dev/config/server-options.html) - Server configuration including port

**Process Management:**

- [Node child_process](https://nodejs.org/api/child_process.html) - How tools spawn subprocesses
- [stdout/stderr parsing](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) - How Playwright reads Vite's logs

### Related Patterns in This Project

**Other worktree-aware configurations:**

- `.gitignore` - Ignores worktree-local files (node_modules, build outputs)
- Symlinks to `.shared/` - Configuration shared across worktrees
- `setup-worktree.sh` - Script to create new worktrees with correct setup

## Questions to Think About

1. **What if we had a shared database instead of localStorage?**
   - How would you prevent test data conflicts between worktrees?
   - Would you use separate test databases? Transactions? Namespacing?

2. **What if E2E tests needed to test API endpoints?**
   - How would you handle API server port conflicts?
   - Would you mock the API or run real servers?

3. **How would you handle this in CI/CD?**
   - Should CI use dynamic ports or fixed ports?
   - What if CI runs multiple jobs in parallel on the same machine?

4. **Could this approach break anything?**
   - What if a test hardcodes `http://localhost:5173`?
   - How would you catch that in code review?

5. **What about hot module replacement (HMR)?**
   - Vite's HMR uses WebSockets on the same port
   - Does this configuration affect HMR?
   - (Hint: No - HMR follows the HTTP port)

---

**Remember:** Advanced workflows (parallel development, CI/CD, containerization) require thinking about resource conflicts. Hardcoded ports, shared databases, and global state all become problems. Design for flexibility and isolation.
