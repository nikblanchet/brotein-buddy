# Inventory Management Screen: Multiple Data Views and Testing Strategies

**Deliverable:** 2.5 - Inventory Management Screen
**Created:** 2025-10-30
**Author:** Claude Code

---

## Overview

The Inventory Management screen is where users view and organize their protein shake inventory. This is the most complex component in BroteinBuddy so far - it presents the same data in two different visual formats (visual stack view and sortable table), handles empty states, manages modal dialogs, and provides navigation to other screens.

This component demonstrates patterns you'll encounter constantly in real-world development: how to structure complex UI logic, when to extract testable utilities, how to handle different data views, and how to write comprehensive tests that catch regressions without becoming brittle.

## What We Built

The inventory screen provides two complementary ways to view box inventory:

### Visual View (Default)

- **Stack layout**: Boxes displayed in CSS Grid columns by stack number
- **Vertical stacking**: Boxes ordered bottom-to-top by height
- **Color coding**: Each flavor gets a consistent color (generated from flavor ID)
- **Visual indicators**: Open boxes have a white border, quantity shown on each box
- **Out-of-stock section**: Flavors with zero inventory shown separately below
- **Interactive**: Click any box to edit it

### Table View

- **Three columns**: Flavor (with color dot), Quantity, Location
- **Sortable**: Click column headers to sort ascending/descending
- **Compact**: Good for quickly scanning inventory numbers
- **Same interactivity**: Click rows to edit boxes

### Common Features

- **View toggle**: Switch between visual and table modes
- **New flavor modal**: Add flavors with optional "exclude from random" flag
- **Navigation**: Navigate to rearrange screen or individual box edit
- **Empty states**: Helpful messages when no boxes exist
- **Keyboard accessibility**: Visual box cards support Enter/Space activation

## Why This Approach

### The Problem: One Component, Many Responsibilities

When you have a screen that does this much, the biggest risk is creating an unmaintainable blob of code. The component file could easily become 1000+ lines with all the logic inline.

We faced several design questions:

1. Where should data transformations live?
2. How do we keep the component testable?
3. How do we handle the complexity of two different views?
4. What's the right balance between unit and E2E tests?

### Option 1: Keep All Logic in Component (REJECTED)

```svelte
<script lang="ts">
  // Everything inline
  let boxesByStack = $derived(() => {
    const grouped = new Map();
    $appState.boxes.forEach((box) => {
      const stack = box.location.stack;
      if (!grouped.has(stack)) {
        grouped.set(stack, []);
      }
      grouped.get(stack).push(box);
    });
    // ... 30 more lines of sorting and grouping
    return grouped;
  });

  // Similar inline logic for out-of-stock, sorting, colors...
</script>
```

**Pros:**

- Everything in one file
- Easy to find code

**Cons:**

- Hard to test transformations without rendering component
- Difficult to understand the flow
- Mixing view logic with business logic
- Can't reuse logic elsewhere

### Option 2: Extract Everything to Separate Modules (OVER-ENGINEERED)

Create separate files for every tiny function:

- `box-grouper.ts`
- `box-sorter.ts`
- `flavor-color-generator.ts`
- `location-formatter.ts`
- `out-of-stock-detector.ts`

**Pros:**

- Maximum testability
- Maximum reusability

**Cons:**

- Over-abstraction for a small app
- Harder to understand the full picture (code spread across many files)
- Premature optimization

### Option 3: Extract Testable Utilities, Keep UI in Component (CHOSEN)

Create one utility module (`inventory-utils.ts`) with:

- Data transformation functions (grouping, sorting, filtering)
- Pure utility functions (color generation, formatting)

Keep in component:

- UI state (view mode, modal open/closed, form values)
- Event handlers
- Navigation logic
- Reactive derivations that call utilities

**Pros:**

- Clear separation: business logic vs UI logic
- Easy to unit test transformations
- Component stays focused on rendering and user interaction
- One utility file is easy to navigate

**Cons:**

- Slightly more files than Option 1
- Need to decide what belongs in utilities vs component

**Why we chose this:** It's the sweet spot for a medium-complexity component. We get the testability we need without over-engineering. The 209-line utility module is easy to understand and test (31 unit tests, 100% coverage), while the 666-line component stays focused on UI concerns.

## How It Works

### Architecture: Component + Utilities

```
Inventory.svelte (666 lines)
├─ UI State Management
│  ├─ viewMode: 'visual' | 'table'
│  ├─ Modal state (isOpen, formValues)
│  └─ Sorting state (column, direction)
│
├─ Reactive Derivations
│  ├─ boxesWithFlavors (join boxes + flavors)
│  ├─ boxesByStack (calls groupBoxesByStack utility)
│  ├─ outOfStockFlavors (calls getOutOfStockFlavors utility)
│  └─ sortedTableData (calls sortBoxes utility)
│
├─ Event Handlers
│  ├─ Navigation (handleBoxClick, handleRearrangeClick)
│  ├─ Modal (open/close/save new flavor)
│  ├─ View toggle
│  └─ Table sorting
│
└─ Render Logic
   ├─ Visual view (stacks, boxes, out-of-stock)
   └─ Table view (sortable columns, rows)

inventory-utils.ts (209 lines)
├─ groupBoxesByStack() - O(n log n)
├─ getOutOfStockFlavors() - O(n*m)
├─ sortBoxes() - O(n log n)
├─ getFlavorColor() - O(n) string hash
└─ formatLocation() - O(1) string formatter
```

### Key Design Patterns

#### 1. Pure Utility Functions

All utility functions are **pure** - same inputs always produce same outputs, no side effects:

```typescript
/**
 * Pure function: deterministic color from flavor ID
 */
export function getFlavorColor(flavorId: string): string {
  let hash = 0;
  for (let i = 0; i < flavorId.length; i++) {
    hash = flavorId.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash % COLOR_HUE_MAX);
  return `hsl(${hue}, ${COLOR_SATURATION}%, ${COLOR_LIGHTNESS}%)`;
}
```

**Why pure functions matter:**

- Easy to test (no mocking required)
- Easy to reason about (no hidden dependencies)
- Can be memoized/cached if needed
- No race conditions or timing bugs

#### 2. Svelte 5 Reactive Derivations with $derived

The component joins boxes with their flavor information reactively:

```svelte
let boxesWithFlavors = $derived(
  $appState.boxes.map((box) => {
    const flavor = $appState.flavors.find((f) => f.id === box.flavorId);
    return { box, flavor: flavor || null };
  })
);
```

This automatically recomputes whenever `$appState.boxes` or `$appState.flavors` changes. Then other derivations chain from this:

```svelte
let boxesByStack = $derived(groupBoxesByStack(boxesWithFlavors)); let outOfStockFlavors =
$derived(getOutOfStockFlavors($appState.flavors, $appState.boxes)); let sortedTableData =
$derived(sortBoxes(boxesWithFlavors, sortColumn, sortDirection));
```

**Why this pattern:** Reactive derivations give us automatic updates without manual subscription management. The utility functions stay pure and testable. When state changes, Svelte's fine-grained reactivity updates only what's needed.

#### 3. View-Specific Rendering with Conditional Blocks

Rather than trying to share markup between views, we render completely separate structures:

```svelte
{#if viewMode === 'visual'}
  <div class="visual-view">
    <!-- Stack layout with CSS Grid -->
  </div>
{/if}

{#if viewMode === 'table'}
  <div class="table-view">
    <!-- HTML table with sortable headers -->
  </div>
{/if}
```

**Why separate renders:** The two views are fundamentally different structures (grid vs table). Trying to share markup would create complexity. Separate structures are clearer and easier to style.

Svelte only renders the active branch, so there's no performance penalty.

#### 4. Keyboard Accessibility on Visual Boxes

Visual box cards are clickable but aren't real `<button>` elements (they're styled `<div>`s). We make them keyboard-accessible:

```svelte
<div
  class="box-visual"
  role="button"
  tabindex="0"
  onclick={() => handleBoxClick(box.id)}
  onkeydown={(e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleBoxClick(box.id);
    }
  }}
>
```

**What this does:**

- `role="button"` tells screen readers this is a button
- `tabindex="0"` makes it keyboard-focusable
- `onkeydown` handles Enter and Space (standard button keys)
- `e.preventDefault()` prevents scrolling on Space

**Why this matters:** Not everyone uses a mouse. Keyboard users need the same functionality. This is basic accessibility - if something is clickable, it should be keyboard-activatable.

## Testing Strategy: Unit + E2E

We wrote 67 tests across two files:

- **31 unit tests** for `inventory-utils.ts` (100% coverage)
- **36 E2E tests** for the full component

### Unit Tests: Fast, Focused, Comprehensive

Unit tests verify the utility functions in isolation:

```typescript
describe('groupBoxesByStack', () => {
  it('groups boxes by stack number', () => {
    const boxes = [
      createBoxWithFlavor(createBox({ location: { stack: 1, height: 0 } }), null),
      createBoxWithFlavor(createBox({ location: { stack: 2, height: 0 } }), null),
    ];
    const result = groupBoxesByStack(boxes);
    expect(result.size).toBe(2);
  });

  it('sorts boxes within each stack by height', () => {
    // ...
  });

  it('returns empty Map when no boxes provided', () => {
    // ...
  });
});
```

**What unit tests buy us:**

- **Speed**: 31 tests run in milliseconds
- **Coverage**: 100% line/branch coverage
- **Precision**: Know exactly which function has a bug
- **Confidence**: Transformations work correctly

### E2E Tests: Slow, Holistic, Realistic

E2E tests verify the component works in a real browser:

```typescript
test('displays boxes in visual view grouped by stack', async ({ page, context }) => {
  await context.addInitScript(() => {
    localStorage.setItem('BROTEINBUDDY_APP_STATE', JSON.stringify(testState));
  });
  await page.goto('http://localhost:5173/#/inventory');

  const stack1 = page.locator('.stack[data-stack="1"]');
  await expect(stack1).toBeVisible();

  const boxes = stack1.locator('.box-visual');
  await expect(boxes).toHaveCount(2);
});
```

**What E2E tests buy us:**

- **Integration**: Verify component + utilities + state + routing work together
- **Realism**: Test actual user interactions in real browser
- **Regressions**: Catch CSS issues, event handler bugs, state sync problems
- **Confidence**: The feature actually works end-to-end

### The Balance

We don't unit test the component file itself (Inventory.svelte). Why?

**Testing Svelte components with @testing-library/svelte is currently problematic** due to Svelte 5 compatibility issues (tracked in issue #3). Instead of fighting the tooling, we:

1. **Extract testable logic to utilities** - unit test those thoroughly
2. **Use E2E tests for integration** - test the full component in a real browser
3. **Keep component simple** - mostly just rendering and event handlers

This gives us 100% coverage on business logic (utilities) plus comprehensive integration testing (E2E), without getting stuck on tooling issues.

When @testing-library/svelte supports Svelte 5 properly, we can add component-level integration tests as a middle layer.

## Design Trade-offs

### What We Optimized For

1. **Testability**: Extracted pure functions so we can test transformations without rendering UI
2. **Maintainability**: Clear separation between business logic and UI logic
3. **User experience**: Two complementary views of the same data
4. **Accessibility**: Keyboard navigation, semantic HTML, ARIA roles

### What We Sacrificed

1. **Perfect DRY**: The two views have some duplicated concepts (rendering box info)
   - **Why that's okay**: Forced sharing between fundamentally different structures (grid vs table) would create more complexity than it saves

2. **Memoization**: We're not caching expensive computations
   - **Why that's okay**: Our dataset is small (typical user has <50 boxes). Grouping and sorting are fast enough. If we had thousands of boxes, we'd add `useMemo` or similar

3. **Component-level unit tests**: We're using E2E instead
   - **Why that's okay**: Tooling limitations (Svelte 5 + testing-library). Our coverage is good via utilities (unit) + full component (E2E)

4. **Advanced table features**: No search/filter, no inline editing, no bulk actions
   - **Why that's okay**: v1 scope - we can add these later if users need them

## Real-World Compromises

### localStorage Key Fix

During development, we discovered the component was using the wrong localStorage key (`'brotein-buddy-state'` instead of `'BROTEINBUDDY_APP_STATE'`). This was caught by E2E tests failing.

**The bug:** E2E tests populated localStorage with `BROTEINBUDDY_APP_STATE`, but the app was reading from a different key, so boxes weren't loading.

**The fix:** Corrected E2E tests to use the right key (matching `storage.ts`).

**Lesson:** This is why E2E tests are valuable - they catch integration issues like "component expects different state key than storage layer provides."

### Sort State Management

Table sorting has two pieces of state: `sortColumn` and `sortDirection`. Initial implementation had a bug:

```svelte
// BUGGY: Starts with 'asc', but user expects first click to show ascending
let sortDirection = $state<SortDirection>('asc');

function handleColumnClick(column: SortColumn) {
  if (sortColumn === column) {
    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc'; // Toggle
  } else {
    sortColumn = column;
    sortDirection = 'asc'; // Reset to asc for new column
  }
}
```

**The problem:** Table loads with `sortColumn='flavor'` and `sortDirection='asc'`, so data is already sorted ascending by flavor. User clicks "Flavor" header expecting ascending sort, but the code toggles to descending instead.

**The fix:** E2E tests explicitly check initial sort state:

```typescript
test('initially sorts by flavor ascending', async ({ page }) => {
  const rows = await page.locator('.table-row').all();
  const firstRow = await rows[0].locator('.flavor-cell').textContent();
  expect(firstRow).toContain('Chocolate'); // Alphabetically first
});
```

This caught the issue. Now we're conscious of matching UI behavior to user expectations.

**Lesson:** Stateful UI (like sorting) needs tests for initial state + all state transitions. It's easy to get edge cases wrong.

### Dynamic Port Configuration for Worktrees

The original `playwright.config.ts` hardcoded `baseURL: 'http://localhost:5173'`. This breaks when multiple worktrees run dev servers simultaneously (they use different ports like 5174, 5175, etc.).

**The problem:** Worktree A runs tests, starts server on 5173. Worktree B runs tests, server already on 5173 conflicts.

**The fix:** Remove hardcoded `baseURL`, rely on `webServer.url`:

```typescript
export default defineConfig({
  use: {
    // Remove hardcoded baseURL
    trace: 'on-first-retry',
  },
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173', // Vite will auto-increment if busy
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  },
});
```

Vite automatically picks the next available port when 5173 is busy. Playwright follows `webServer.url` resolution.

**Lesson:** Parallel worktree development requires tooling that handles port conflicts gracefully. Hardcoded ports are fine for single-dev workflows but break in parallel workflows.

## What You Should Learn From This

### 1. Separate Business Logic from UI Logic

**Pattern:** Extract data transformations to pure utility functions. Keep component focused on rendering and user interaction.

**When to use:**

- Component has complex data transformations
- Logic is reusable or independently testable
- You want fast unit tests

**When to avoid:**

- Component is simple (just rendering props)
- Logic is UI-specific (DOM manipulation, animations)
- Premature abstraction (wait until you need it)

### 2. Multiple Views of the Same Data

**Pattern:** Provide complementary visualizations (visual grid + sortable table). Use conditional rendering.

**When to use:**

- Different users have different preferences
- Different tasks benefit from different views
- Data naturally supports multiple interpretations

**When to avoid:**

- Views are nearly identical (just switch between them is noise)
- Maintaining both views doubles maintenance cost
- Users won't use the second view

### 3. Pure Functions Enable Better Testing

**Pattern:** Functions with no side effects, no external dependencies, deterministic outputs.

```typescript
// PURE: Easy to test
function getFlavorColor(flavorId: string): string {
  const hash = hashString(flavorId);
  return `hsl(${hash % 360}, 65%, 55%)`;
}

// IMPURE: Harder to test (depends on global state)
function getFlavorColor(flavorId: string): string {
  const flavor = $appState.flavors.find((f) => f.id === flavorId);
  return flavor?.color || 'gray';
}
```

**When to use:**

- Utilities, helpers, transformations
- Anywhere you can avoid side effects

**When to avoid:**

- Interacting with external systems (APIs, localStorage, DOM)
- Managing state (that's inherently stateful)

### 4. E2E Tests Catch Integration Issues

**Pattern:** Test the full user flow in a real browser. Don't mock state, routing, or localStorage.

**When to use:**

- Verifying features work end-to-end
- Testing component + state + routing integration
- Catching CSS/layout bugs
- Testing across browsers

**When to avoid:**

- Testing low-level utility logic (use unit tests)
- Testing every edge case (E2E is slow)
- When unit/integration tests already cover it

### 5. Accessibility Is Not Optional

**Pattern:** If it's clickable, it must be keyboard-accessible. Use semantic HTML or add `role`, `tabindex`, `onkeydown`.

**When to use:**

- Always, for any interactive element
- Especially when using `<div>` or `<span>` as buttons

**Best practice:**

```svelte
<!-- GOOD: Real button (semantic, accessible by default) -->
<button onclick={handleClick}>Click me</button>

<!-- ACCEPTABLE: Styled div with accessibility -->
<div role="button" tabindex="0" onclick={handleClick} onkeydown={handleEnterSpace}>Click me</div>

<!-- BAD: Not keyboard accessible -->
<div onclick={handleClick}>Click me</div>
```

### 6. Tool Around Known Issues

**Pattern:** When tooling has bugs (Svelte 5 + testing-library), adjust your testing strategy rather than blocking progress.

**What we did:**

- Can't unit test Svelte 5 components with testing-library? Extract logic to utilities, unit test those
- Use E2E for integration coverage instead

**Lesson:** Don't let tooling issues block feature development. Find workarounds, file issues, keep moving. Come back when tools catch up.

## Going Deeper

### Learn More About These Topics

**Data Transformations:**

- [Array.prototype.map, filter, reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - Core array methods
- [Map and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) - Keyed collections

**Svelte 5 Reactivity:**

- [Svelte 5 Runes](https://svelte.dev/docs/svelte/$derived) - $derived, $state, $effect
- [Fine-grained reactivity](https://www.youtube.com/watch?v=AdNJ3fydeao) - How Svelte 5 reactivity works

**Testing Strategies:**

- [Testing Trophy](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications) - Balance of test types
- [Playwright Best Practices](https://playwright.dev/docs/best-practices) - E2E testing patterns

**Accessibility:**

- [ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/) - Patterns for interactive widgets
- [WebAIM](https://webaim.org/) - Accessibility guidelines and tools

### Related Patterns in This Project

**Similar extraction of utilities:**

- `box-selection.ts` (deliverable 1.3) - Priority sorting algorithm
- `random-selection.ts` (deliverable 1.4) - Weighted random selection
- `storage.ts` (deliverable 1.2) - localStorage abstraction

**Similar multi-view patterns:**

- This is the first multi-view component, but the pattern applies anywhere users benefit from different perspectives on the same data

**Similar testing approaches:**

- All Phase 1 utilities have 90-100% unit test coverage
- All Phase 2 components have E2E tests
- Pattern: unit test utilities, E2E test features

## Questions to Think About

1. **When would you add a third view?** (e.g., "timeline view" showing when boxes were added)
   - What would that view show that the other two don't?
   - How would you structure the utility function?

2. **How would you add filtering/search to the table view?**
   - Would you extract that to a utility or keep it in the component?
   - How would filtering interact with sorting?

3. **The color generation is deterministic but not customizable.**
   - How would you let users pick custom colors per flavor?
   - Where would you store that preference?
   - How would you migrate existing data?

4. **What if the dataset grew to 1000 boxes?**
   - Would the current approach still perform well?
   - What would you optimize first?
   - Would you change the testing strategy?

5. **How would you add drag-and-drop rearranging directly in the visual view?**
   - What would the UX be?
   - How would you validate moves (no floating boxes)?
   - How would that interact with the existing "Rearrange" screen (deliverable 2.7)?

---

**Remember:** This component balances multiple concerns - testability, user experience, maintainability, accessibility. The patterns here (extract utilities, pure functions, E2E tests, keyboard support) apply to most complex components you'll build. Take these lessons forward.
